// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.BaseDefine.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "IM.BaseDefine.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace BaseDefine {

void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto() {
  delete IpAddr::default_instance_;
  delete UserInfo::default_instance_;
  delete ContactSessionInfo::default_instance_;
  delete UserStat::default_instance_;
  delete UnreadInfo::default_instance_;
  delete MsgInfo::default_instance_;
  delete GroupVersionInfo::default_instance_;
  delete GroupInfo::default_instance_;
  delete UserTokenInfo::default_instance_;
  delete PushResult::default_instance_;
  delete ShieldStatus::default_instance_;
  delete OfflineFileInfo::default_instance_;
  delete DepartInfo::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_IM_2eBaseDefine_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  IpAddr::default_instance_ = new IpAddr();
  UserInfo::default_instance_ = new UserInfo();
  ContactSessionInfo::default_instance_ = new ContactSessionInfo();
  UserStat::default_instance_ = new UserStat();
  UnreadInfo::default_instance_ = new UnreadInfo();
  MsgInfo::default_instance_ = new MsgInfo();
  GroupVersionInfo::default_instance_ = new GroupVersionInfo();
  GroupInfo::default_instance_ = new GroupInfo();
  UserTokenInfo::default_instance_ = new UserTokenInfo();
  PushResult::default_instance_ = new PushResult();
  ShieldStatus::default_instance_ = new ShieldStatus();
  OfflineFileInfo::default_instance_ = new OfflineFileInfo();
  DepartInfo::default_instance_ = new DepartInfo();
  IpAddr::default_instance_->InitAsDefaultInstance();
  UserInfo::default_instance_->InitAsDefaultInstance();
  ContactSessionInfo::default_instance_->InitAsDefaultInstance();
  UserStat::default_instance_->InitAsDefaultInstance();
  UnreadInfo::default_instance_->InitAsDefaultInstance();
  MsgInfo::default_instance_->InitAsDefaultInstance();
  GroupVersionInfo::default_instance_->InitAsDefaultInstance();
  GroupInfo::default_instance_->InitAsDefaultInstance();
  UserTokenInfo::default_instance_->InitAsDefaultInstance();
  PushResult::default_instance_->InitAsDefaultInstance();
  ShieldStatus::default_instance_->InitAsDefaultInstance();
  OfflineFileInfo::default_instance_->InitAsDefaultInstance();
  DepartInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_IM_2eBaseDefine_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_IM_2eBaseDefine_2eproto_once_);
void protobuf_AddDesc_IM_2eBaseDefine_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_IM_2eBaseDefine_2eproto_once_,
                 &protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_IM_2eBaseDefine_2eproto {
  StaticDescriptorInitializer_IM_2eBaseDefine_2eproto() {
    protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  }
} static_descriptor_initializer_IM_2eBaseDefine_2eproto_;
#endif
bool ServiceID_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

bool LoginCmdID_IsValid(int value) {
  switch(value) {
    case 257:
    case 258:
    case 259:
    case 260:
    case 261:
    case 262:
    case 263:
    case 264:
    case 265:
    case 266:
    case 267:
      return true;
    default:
      return false;
  }
}

bool BuddyListCmdID_IsValid(int value) {
  switch(value) {
    case 513:
    case 514:
    case 515:
    case 516:
    case 517:
    case 518:
    case 519:
    case 520:
    case 521:
    case 522:
    case 523:
    case 524:
    case 525:
    case 526:
    case 527:
    case 528:
    case 529:
    case 530:
    case 531:
    case 532:
    case 533:
    case 534:
    case 535:
    case 536:
    case 537:
    case 538:
    case 539:
    case 540:
    case 541:
    case 542:
    case 543:
    case 544:
    case 545:
    case 546:
    case 547:
    case 548:
    case 549:
    case 550:
    case 551:
      return true;
    default:
      return false;
  }
}

bool MessageCmdID_IsValid(int value) {
  switch(value) {
    case 769:
    case 770:
    case 771:
    case 772:
    case 773:
    case 774:
    case 775:
    case 776:
    case 777:
    case 778:
    case 779:
    case 780:
    case 781:
    case 782:
    case 783:
    case 784:
      return true;
    default:
      return false;
  }
}

bool GroupCmdID_IsValid(int value) {
  switch(value) {
    case 1025:
    case 1026:
    case 1027:
    case 1028:
    case 1029:
    case 1030:
    case 1031:
    case 1032:
    case 1033:
    case 1034:
    case 1035:
      return true;
    default:
      return false;
  }
}

bool FileCmdID_IsValid(int value) {
  switch(value) {
    case 1281:
    case 1282:
    case 1283:
    case 1284:
    case 1285:
    case 1286:
    case 1287:
    case 1288:
    case 1289:
    case 1290:
    case 1291:
    case 1292:
      return true;
    default:
      return false;
  }
}

bool SwitchServiceCmdID_IsValid(int value) {
  switch(value) {
    case 1537:
      return true;
    default:
      return false;
  }
}

bool OtherCmdID_IsValid(int value) {
  switch(value) {
    case 1793:
      return true;
    default:
      return false;
  }
}

bool InternalCmdId_IsValid(int value) {
  switch(value) {
    case 2050:
    case 2051:
    case 2052:
    case 2053:
    case 2054:
    case 2055:
    case 2056:
    case 2057:
    case 2058:
    case 2059:
    case 2061:
    case 2062:
    case 2063:
    case 2064:
    case 2065:
    case 2066:
    case 2067:
    case 2068:
    case 2069:
    case 2070:
    case 2071:
    case 2072:
      return true;
    default:
      return false;
  }
}

bool OrderMsgStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

bool ResultType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

bool KickReasonType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool UserStatType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool SessionType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool MsgType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 17:
    case 18:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 49:
    case 50:
      return true;
    default:
      return false;
  }
}

bool ClientType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

bool GroupType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool GroupModifyType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool FileType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

bool ClientFileState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

bool ClientFileRole_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

bool FileServerError_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

bool SessionStatusType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

bool DepartmentStatusType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

bool FriendResStatusType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int IpAddr::kIpFieldNumber;
const int IpAddr::kPortFieldNumber;
#endif  // !_MSC_VER

IpAddr::IpAddr()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.IpAddr)
}

void IpAddr::InitAsDefaultInstance() {
}

IpAddr::IpAddr(const IpAddr& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.IpAddr)
}

void IpAddr::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IpAddr::~IpAddr() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.IpAddr)
  SharedDtor();
}

void IpAddr::SharedDtor() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void IpAddr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const IpAddr& IpAddr::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

IpAddr* IpAddr::default_instance_ = NULL;

IpAddr* IpAddr::New() const {
  return new IpAddr;
}

void IpAddr::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_ip()) {
      if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        ip_->clear();
      }
    }
    port_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool IpAddr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.IpAddr)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ip = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_port;
        break;
      }

      // required uint32 port = 2;
      case 2: {
        if (tag == 16) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.IpAddr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.IpAddr)
  return false;
#undef DO_
}

void IpAddr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.IpAddr)
  // required string ip = 1;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->ip(), output);
  }

  // required uint32 port = 2;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->port(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.IpAddr)
}

int IpAddr::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string ip = 1;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

    // required uint32 port = 2;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->port());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IpAddr::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IpAddr*>(&from));
}

void IpAddr::MergeFrom(const IpAddr& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void IpAddr::CopyFrom(const IpAddr& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpAddr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void IpAddr::Swap(IpAddr* other) {
  if (other != this) {
    std::swap(ip_, other->ip_);
    std::swap(port_, other->port_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string IpAddr::GetTypeName() const {
  return "IM.BaseDefine.IpAddr";
}


// ===================================================================

#ifndef _MSC_VER
const int UserInfo::kUserIdFieldNumber;
const int UserInfo::kUserNicknameFieldNumber;
const int UserInfo::kUserGenderFieldNumber;
const int UserInfo::kUserBirthdayFieldNumber;
const int UserInfo::kUserHeadlinkFieldNumber;
const int UserInfo::kUserLevelFieldNumber;
const int UserInfo::kUserStatusFieldNumber;
const int UserInfo::kUserUidFieldNumber;
const int UserInfo::kUserPhoneFieldNumber;
const int UserInfo::kFriendGroupidFieldNumber;
const int UserInfo::kFriendRemarkFieldNumber;
const int UserInfo::kFriendStatusFieldNumber;
const int UserInfo::kUserTypeFieldNumber;
const int UserInfo::kUserIscheckFieldNumber;
const int UserInfo::kUserDescFieldNumber;
#endif  // !_MSC_VER

UserInfo::UserInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.UserInfo)
}

void UserInfo::InitAsDefaultInstance() {
}

UserInfo::UserInfo(const UserInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserInfo)
}

void UserInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = 0u;
  user_nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_gender_ = 0u;
  user_birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_headlink_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_level_ = 0u;
  user_status_ = 0u;
  user_uid_ = 0u;
  user_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  friend_groupid_ = 0u;
  friend_remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  friend_status_ = 0u;
  user_type_ = 0u;
  user_ischeck_ = 0u;
  user_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserInfo::~UserInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserInfo)
  SharedDtor();
}

void UserInfo::SharedDtor() {
  if (user_nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_nickname_;
  }
  if (user_birthday_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_birthday_;
  }
  if (user_headlink_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_headlink_;
  }
  if (user_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_phone_;
  }
  if (friend_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete friend_remark_;
  }
  if (user_desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_desc_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserInfo& UserInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

UserInfo* UserInfo::default_instance_ = NULL;

UserInfo* UserInfo::New() const {
  return new UserInfo;
}

void UserInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<UserInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(user_id_, user_gender_);
    ZR_(user_level_, user_status_);
    if (has_user_nickname()) {
      if (user_nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_nickname_->clear();
      }
    }
    if (has_user_birthday()) {
      if (user_birthday_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_birthday_->clear();
      }
    }
    if (has_user_headlink()) {
      if (user_headlink_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_headlink_->clear();
      }
    }
    user_uid_ = 0u;
  }
  if (_has_bits_[8 / 32] & 32512) {
    ZR_(friend_status_, user_type_);
    if (has_user_phone()) {
      if (user_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_phone_->clear();
      }
    }
    friend_groupid_ = 0u;
    if (has_friend_remark()) {
      if (friend_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        friend_remark_->clear();
      }
    }
    user_ischeck_ = 0u;
    if (has_user_desc()) {
      if (user_desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_desc_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UserInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.UserInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_user_nickname;
        break;
      }

      // required string user_nickname = 2;
      case 2: {
        if (tag == 18) {
         parse_user_nickname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_nickname()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_user_gender;
        break;
      }

      // required uint32 user_gender = 3;
      case 3: {
        if (tag == 24) {
         parse_user_gender:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_gender_)));
          set_has_user_gender();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_user_birthday;
        break;
      }

      // required string user_birthday = 4;
      case 4: {
        if (tag == 34) {
         parse_user_birthday:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_birthday()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_user_headlink;
        break;
      }

      // required string user_headlink = 5;
      case 5: {
        if (tag == 42) {
         parse_user_headlink:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_headlink()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_user_level;
        break;
      }

      // required uint32 user_level = 6;
      case 6: {
        if (tag == 48) {
         parse_user_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_level_)));
          set_has_user_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_user_status;
        break;
      }

      // required uint32 user_status = 7;
      case 7: {
        if (tag == 56) {
         parse_user_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_status_)));
          set_has_user_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_user_uid;
        break;
      }

      // optional uint32 user_uid = 8;
      case 8: {
        if (tag == 64) {
         parse_user_uid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_uid_)));
          set_has_user_uid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_user_phone;
        break;
      }

      // optional string user_phone = 9;
      case 9: {
        if (tag == 74) {
         parse_user_phone:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_phone()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_friend_groupid;
        break;
      }

      // optional uint32 friend_groupid = 10;
      case 10: {
        if (tag == 80) {
         parse_friend_groupid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &friend_groupid_)));
          set_has_friend_groupid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_friend_remark;
        break;
      }

      // optional string friend_remark = 11;
      case 11: {
        if (tag == 90) {
         parse_friend_remark:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_friend_remark()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_friend_status;
        break;
      }

      // optional uint32 friend_status = 12;
      case 12: {
        if (tag == 96) {
         parse_friend_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &friend_status_)));
          set_has_friend_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_user_type;
        break;
      }

      // optional uint32 user_type = 13;
      case 13: {
        if (tag == 104) {
         parse_user_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_type_)));
          set_has_user_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_user_ischeck;
        break;
      }

      // optional uint32 user_ischeck = 14;
      case 14: {
        if (tag == 112) {
         parse_user_ischeck:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_ischeck_)));
          set_has_user_ischeck();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_user_desc;
        break;
      }

      // optional string user_desc = 15;
      case 15: {
        if (tag == 122) {
         parse_user_desc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_desc()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.UserInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.UserInfo)
  return false;
#undef DO_
}

void UserInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.UserInfo)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required string user_nickname = 2;
  if (has_user_nickname()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->user_nickname(), output);
  }

  // required uint32 user_gender = 3;
  if (has_user_gender()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->user_gender(), output);
  }

  // required string user_birthday = 4;
  if (has_user_birthday()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->user_birthday(), output);
  }

  // required string user_headlink = 5;
  if (has_user_headlink()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->user_headlink(), output);
  }

  // required uint32 user_level = 6;
  if (has_user_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->user_level(), output);
  }

  // required uint32 user_status = 7;
  if (has_user_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->user_status(), output);
  }

  // optional uint32 user_uid = 8;
  if (has_user_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->user_uid(), output);
  }

  // optional string user_phone = 9;
  if (has_user_phone()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->user_phone(), output);
  }

  // optional uint32 friend_groupid = 10;
  if (has_friend_groupid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->friend_groupid(), output);
  }

  // optional string friend_remark = 11;
  if (has_friend_remark()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->friend_remark(), output);
  }

  // optional uint32 friend_status = 12;
  if (has_friend_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->friend_status(), output);
  }

  // optional uint32 user_type = 13;
  if (has_user_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->user_type(), output);
  }

  // optional uint32 user_ischeck = 14;
  if (has_user_ischeck()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->user_ischeck(), output);
  }

  // optional string user_desc = 15;
  if (has_user_desc()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      15, this->user_desc(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.UserInfo)
}

int UserInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required string user_nickname = 2;
    if (has_user_nickname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_nickname());
    }

    // required uint32 user_gender = 3;
    if (has_user_gender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_gender());
    }

    // required string user_birthday = 4;
    if (has_user_birthday()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_birthday());
    }

    // required string user_headlink = 5;
    if (has_user_headlink()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_headlink());
    }

    // required uint32 user_level = 6;
    if (has_user_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_level());
    }

    // required uint32 user_status = 7;
    if (has_user_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_status());
    }

    // optional uint32 user_uid = 8;
    if (has_user_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_uid());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string user_phone = 9;
    if (has_user_phone()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_phone());
    }

    // optional uint32 friend_groupid = 10;
    if (has_friend_groupid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->friend_groupid());
    }

    // optional string friend_remark = 11;
    if (has_friend_remark()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->friend_remark());
    }

    // optional uint32 friend_status = 12;
    if (has_friend_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->friend_status());
    }

    // optional uint32 user_type = 13;
    if (has_user_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_type());
    }

    // optional uint32 user_ischeck = 14;
    if (has_user_ischeck()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_ischeck());
    }

    // optional string user_desc = 15;
    if (has_user_desc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_desc());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserInfo*>(&from));
}

void UserInfo::MergeFrom(const UserInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_user_nickname()) {
      set_user_nickname(from.user_nickname());
    }
    if (from.has_user_gender()) {
      set_user_gender(from.user_gender());
    }
    if (from.has_user_birthday()) {
      set_user_birthday(from.user_birthday());
    }
    if (from.has_user_headlink()) {
      set_user_headlink(from.user_headlink());
    }
    if (from.has_user_level()) {
      set_user_level(from.user_level());
    }
    if (from.has_user_status()) {
      set_user_status(from.user_status());
    }
    if (from.has_user_uid()) {
      set_user_uid(from.user_uid());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_user_phone()) {
      set_user_phone(from.user_phone());
    }
    if (from.has_friend_groupid()) {
      set_friend_groupid(from.friend_groupid());
    }
    if (from.has_friend_remark()) {
      set_friend_remark(from.friend_remark());
    }
    if (from.has_friend_status()) {
      set_friend_status(from.friend_status());
    }
    if (from.has_user_type()) {
      set_user_type(from.user_type());
    }
    if (from.has_user_ischeck()) {
      set_user_ischeck(from.user_ischeck());
    }
    if (from.has_user_desc()) {
      set_user_desc(from.user_desc());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UserInfo::CopyFrom(const UserInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void UserInfo::Swap(UserInfo* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(user_nickname_, other->user_nickname_);
    std::swap(user_gender_, other->user_gender_);
    std::swap(user_birthday_, other->user_birthday_);
    std::swap(user_headlink_, other->user_headlink_);
    std::swap(user_level_, other->user_level_);
    std::swap(user_status_, other->user_status_);
    std::swap(user_uid_, other->user_uid_);
    std::swap(user_phone_, other->user_phone_);
    std::swap(friend_groupid_, other->friend_groupid_);
    std::swap(friend_remark_, other->friend_remark_);
    std::swap(friend_status_, other->friend_status_);
    std::swap(user_type_, other->user_type_);
    std::swap(user_ischeck_, other->user_ischeck_);
    std::swap(user_desc_, other->user_desc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserInfo::GetTypeName() const {
  return "IM.BaseDefine.UserInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int ContactSessionInfo::kSessionIdFieldNumber;
const int ContactSessionInfo::kSessionTypeFieldNumber;
const int ContactSessionInfo::kSessionStatusFieldNumber;
const int ContactSessionInfo::kUpdatedTimeFieldNumber;
const int ContactSessionInfo::kLatestMsgIdFieldNumber;
const int ContactSessionInfo::kLatestMsgDataFieldNumber;
const int ContactSessionInfo::kLatestMsgTypeFieldNumber;
const int ContactSessionInfo::kLatestMsgFromUserIdFieldNumber;
#endif  // !_MSC_VER

ContactSessionInfo::ContactSessionInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.ContactSessionInfo)
}

void ContactSessionInfo::InitAsDefaultInstance() {
}

ContactSessionInfo::ContactSessionInfo(const ContactSessionInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.ContactSessionInfo)
}

void ContactSessionInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  session_id_ = 0u;
  session_type_ = 1;
  session_status_ = 0;
  updated_time_ = 0u;
  latest_msg_id_ = 0u;
  latest_msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  latest_msg_type_ = 1;
  latest_msg_from_user_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContactSessionInfo::~ContactSessionInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.ContactSessionInfo)
  SharedDtor();
}

void ContactSessionInfo::SharedDtor() {
  if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete latest_msg_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ContactSessionInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ContactSessionInfo& ContactSessionInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

ContactSessionInfo* ContactSessionInfo::default_instance_ = NULL;

ContactSessionInfo* ContactSessionInfo::New() const {
  return new ContactSessionInfo;
}

void ContactSessionInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ContactSessionInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(session_status_, updated_time_);
    session_id_ = 0u;
    session_type_ = 1;
    latest_msg_id_ = 0u;
    if (has_latest_msg_data()) {
      if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        latest_msg_data_->clear();
      }
    }
    latest_msg_type_ = 1;
    latest_msg_from_user_id_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ContactSessionInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.ContactSessionInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 session_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_session_type;
        break;
      }

      // required .IM.BaseDefine.SessionType session_type = 2;
      case 2: {
        if (tag == 16) {
         parse_session_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::SessionType_IsValid(value)) {
            set_session_type(static_cast< ::IM::BaseDefine::SessionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_session_status;
        break;
      }

      // required .IM.BaseDefine.SessionStatusType session_status = 3;
      case 3: {
        if (tag == 24) {
         parse_session_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::SessionStatusType_IsValid(value)) {
            set_session_status(static_cast< ::IM::BaseDefine::SessionStatusType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_updated_time;
        break;
      }

      // required uint32 updated_time = 4;
      case 4: {
        if (tag == 32) {
         parse_updated_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &updated_time_)));
          set_has_updated_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_latest_msg_id;
        break;
      }

      // required uint32 latest_msg_id = 5;
      case 5: {
        if (tag == 40) {
         parse_latest_msg_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &latest_msg_id_)));
          set_has_latest_msg_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_latest_msg_data;
        break;
      }

      // required bytes latest_msg_data = 6;
      case 6: {
        if (tag == 50) {
         parse_latest_msg_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_latest_msg_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_latest_msg_type;
        break;
      }

      // required .IM.BaseDefine.MsgType latest_msg_type = 7;
      case 7: {
        if (tag == 56) {
         parse_latest_msg_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::MsgType_IsValid(value)) {
            set_latest_msg_type(static_cast< ::IM::BaseDefine::MsgType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_latest_msg_from_user_id;
        break;
      }

      // required uint32 latest_msg_from_user_id = 8;
      case 8: {
        if (tag == 64) {
         parse_latest_msg_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &latest_msg_from_user_id_)));
          set_has_latest_msg_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.ContactSessionInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.ContactSessionInfo)
  return false;
#undef DO_
}

void ContactSessionInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.ContactSessionInfo)
  // required uint32 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->session_id(), output);
  }

  // required .IM.BaseDefine.SessionType session_type = 2;
  if (has_session_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->session_type(), output);
  }

  // required .IM.BaseDefine.SessionStatusType session_status = 3;
  if (has_session_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->session_status(), output);
  }

  // required uint32 updated_time = 4;
  if (has_updated_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->updated_time(), output);
  }

  // required uint32 latest_msg_id = 5;
  if (has_latest_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->latest_msg_id(), output);
  }

  // required bytes latest_msg_data = 6;
  if (has_latest_msg_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->latest_msg_data(), output);
  }

  // required .IM.BaseDefine.MsgType latest_msg_type = 7;
  if (has_latest_msg_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->latest_msg_type(), output);
  }

  // required uint32 latest_msg_from_user_id = 8;
  if (has_latest_msg_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->latest_msg_from_user_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.ContactSessionInfo)
}

int ContactSessionInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->session_id());
    }

    // required .IM.BaseDefine.SessionType session_type = 2;
    if (has_session_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_type());
    }

    // required .IM.BaseDefine.SessionStatusType session_status = 3;
    if (has_session_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_status());
    }

    // required uint32 updated_time = 4;
    if (has_updated_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->updated_time());
    }

    // required uint32 latest_msg_id = 5;
    if (has_latest_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->latest_msg_id());
    }

    // required bytes latest_msg_data = 6;
    if (has_latest_msg_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->latest_msg_data());
    }

    // required .IM.BaseDefine.MsgType latest_msg_type = 7;
    if (has_latest_msg_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->latest_msg_type());
    }

    // required uint32 latest_msg_from_user_id = 8;
    if (has_latest_msg_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->latest_msg_from_user_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContactSessionInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ContactSessionInfo*>(&from));
}

void ContactSessionInfo::MergeFrom(const ContactSessionInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_session_type()) {
      set_session_type(from.session_type());
    }
    if (from.has_session_status()) {
      set_session_status(from.session_status());
    }
    if (from.has_updated_time()) {
      set_updated_time(from.updated_time());
    }
    if (from.has_latest_msg_id()) {
      set_latest_msg_id(from.latest_msg_id());
    }
    if (from.has_latest_msg_data()) {
      set_latest_msg_data(from.latest_msg_data());
    }
    if (from.has_latest_msg_type()) {
      set_latest_msg_type(from.latest_msg_type());
    }
    if (from.has_latest_msg_from_user_id()) {
      set_latest_msg_from_user_id(from.latest_msg_from_user_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ContactSessionInfo::CopyFrom(const ContactSessionInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContactSessionInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x000000ff) != 0x000000ff) return false;

  return true;
}

void ContactSessionInfo::Swap(ContactSessionInfo* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(session_type_, other->session_type_);
    std::swap(session_status_, other->session_status_);
    std::swap(updated_time_, other->updated_time_);
    std::swap(latest_msg_id_, other->latest_msg_id_);
    std::swap(latest_msg_data_, other->latest_msg_data_);
    std::swap(latest_msg_type_, other->latest_msg_type_);
    std::swap(latest_msg_from_user_id_, other->latest_msg_from_user_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ContactSessionInfo::GetTypeName() const {
  return "IM.BaseDefine.ContactSessionInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int UserStat::kUserIdFieldNumber;
const int UserStat::kStatusFieldNumber;
const int UserStat::kClientTypeFieldNumber;
#endif  // !_MSC_VER

UserStat::UserStat()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.UserStat)
}

void UserStat::InitAsDefaultInstance() {
}

UserStat::UserStat(const UserStat& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserStat)
}

void UserStat::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  status_ = 1;
  client_type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserStat::~UserStat() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserStat)
  SharedDtor();
}

void UserStat::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserStat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserStat& UserStat::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

UserStat* UserStat::default_instance_ = NULL;

UserStat* UserStat::New() const {
  return new UserStat;
}

void UserStat::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    user_id_ = 0u;
    status_ = 1;
    client_type_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UserStat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.UserStat)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_status;
        break;
      }

      // required .IM.BaseDefine.UserStatType status = 2;
      case 2: {
        if (tag == 16) {
         parse_status:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::UserStatType_IsValid(value)) {
            set_status(static_cast< ::IM::BaseDefine::UserStatType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_client_type;
        break;
      }

      // optional .IM.BaseDefine.ClientType client_type = 3;
      case 3: {
        if (tag == 24) {
         parse_client_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_client_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.UserStat)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.UserStat)
  return false;
#undef DO_
}

void UserStat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.UserStat)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required .IM.BaseDefine.UserStatType status = 2;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->status(), output);
  }

  // optional .IM.BaseDefine.ClientType client_type = 3;
  if (has_client_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->client_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.UserStat)
}

int UserStat::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required .IM.BaseDefine.UserStatType status = 2;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
    }

    // optional .IM.BaseDefine.ClientType client_type = 3;
    if (has_client_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserStat::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserStat*>(&from));
}

void UserStat::MergeFrom(const UserStat& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_status()) {
      set_status(from.status());
    }
    if (from.has_client_type()) {
      set_client_type(from.client_type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UserStat::CopyFrom(const UserStat& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserStat::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void UserStat::Swap(UserStat* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(status_, other->status_);
    std::swap(client_type_, other->client_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserStat::GetTypeName() const {
  return "IM.BaseDefine.UserStat";
}


// ===================================================================

#ifndef _MSC_VER
const int UnreadInfo::kSessionIdFieldNumber;
const int UnreadInfo::kSessionTypeFieldNumber;
const int UnreadInfo::kUnreadCntFieldNumber;
const int UnreadInfo::kLatestMsgIdFieldNumber;
const int UnreadInfo::kLatestMsgDataFieldNumber;
const int UnreadInfo::kLatestMsgTypeFieldNumber;
const int UnreadInfo::kLatestMsgFromUserIdFieldNumber;
#endif  // !_MSC_VER

UnreadInfo::UnreadInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.UnreadInfo)
}

void UnreadInfo::InitAsDefaultInstance() {
}

UnreadInfo::UnreadInfo(const UnreadInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UnreadInfo)
}

void UnreadInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  session_id_ = 0u;
  session_type_ = 1;
  unread_cnt_ = 0u;
  latest_msg_id_ = 0u;
  latest_msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  latest_msg_type_ = 1;
  latest_msg_from_user_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnreadInfo::~UnreadInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UnreadInfo)
  SharedDtor();
}

void UnreadInfo::SharedDtor() {
  if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete latest_msg_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UnreadInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UnreadInfo& UnreadInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

UnreadInfo* UnreadInfo::default_instance_ = NULL;

UnreadInfo* UnreadInfo::New() const {
  return new UnreadInfo;
}

void UnreadInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<UnreadInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(unread_cnt_, latest_msg_id_);
    session_id_ = 0u;
    session_type_ = 1;
    if (has_latest_msg_data()) {
      if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        latest_msg_data_->clear();
      }
    }
    latest_msg_type_ = 1;
    latest_msg_from_user_id_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UnreadInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.UnreadInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 session_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &session_id_)));
          set_has_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_session_type;
        break;
      }

      // required .IM.BaseDefine.SessionType session_type = 2;
      case 2: {
        if (tag == 16) {
         parse_session_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::SessionType_IsValid(value)) {
            set_session_type(static_cast< ::IM::BaseDefine::SessionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_unread_cnt;
        break;
      }

      // required uint32 unread_cnt = 3;
      case 3: {
        if (tag == 24) {
         parse_unread_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &unread_cnt_)));
          set_has_unread_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_latest_msg_id;
        break;
      }

      // required uint32 latest_msg_id = 4;
      case 4: {
        if (tag == 32) {
         parse_latest_msg_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &latest_msg_id_)));
          set_has_latest_msg_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_latest_msg_data;
        break;
      }

      // required bytes latest_msg_data = 5;
      case 5: {
        if (tag == 42) {
         parse_latest_msg_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_latest_msg_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_latest_msg_type;
        break;
      }

      // required .IM.BaseDefine.MsgType latest_msg_type = 6;
      case 6: {
        if (tag == 48) {
         parse_latest_msg_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::MsgType_IsValid(value)) {
            set_latest_msg_type(static_cast< ::IM::BaseDefine::MsgType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_latest_msg_from_user_id;
        break;
      }

      // required uint32 latest_msg_from_user_id = 7;
      case 7: {
        if (tag == 56) {
         parse_latest_msg_from_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &latest_msg_from_user_id_)));
          set_has_latest_msg_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.UnreadInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.UnreadInfo)
  return false;
#undef DO_
}

void UnreadInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.UnreadInfo)
  // required uint32 session_id = 1;
  if (has_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->session_id(), output);
  }

  // required .IM.BaseDefine.SessionType session_type = 2;
  if (has_session_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->session_type(), output);
  }

  // required uint32 unread_cnt = 3;
  if (has_unread_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->unread_cnt(), output);
  }

  // required uint32 latest_msg_id = 4;
  if (has_latest_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->latest_msg_id(), output);
  }

  // required bytes latest_msg_data = 5;
  if (has_latest_msg_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->latest_msg_data(), output);
  }

  // required .IM.BaseDefine.MsgType latest_msg_type = 6;
  if (has_latest_msg_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->latest_msg_type(), output);
  }

  // required uint32 latest_msg_from_user_id = 7;
  if (has_latest_msg_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->latest_msg_from_user_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.UnreadInfo)
}

int UnreadInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 session_id = 1;
    if (has_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->session_id());
    }

    // required .IM.BaseDefine.SessionType session_type = 2;
    if (has_session_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->session_type());
    }

    // required uint32 unread_cnt = 3;
    if (has_unread_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->unread_cnt());
    }

    // required uint32 latest_msg_id = 4;
    if (has_latest_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->latest_msg_id());
    }

    // required bytes latest_msg_data = 5;
    if (has_latest_msg_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->latest_msg_data());
    }

    // required .IM.BaseDefine.MsgType latest_msg_type = 6;
    if (has_latest_msg_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->latest_msg_type());
    }

    // required uint32 latest_msg_from_user_id = 7;
    if (has_latest_msg_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->latest_msg_from_user_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnreadInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UnreadInfo*>(&from));
}

void UnreadInfo::MergeFrom(const UnreadInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_session_id()) {
      set_session_id(from.session_id());
    }
    if (from.has_session_type()) {
      set_session_type(from.session_type());
    }
    if (from.has_unread_cnt()) {
      set_unread_cnt(from.unread_cnt());
    }
    if (from.has_latest_msg_id()) {
      set_latest_msg_id(from.latest_msg_id());
    }
    if (from.has_latest_msg_data()) {
      set_latest_msg_data(from.latest_msg_data());
    }
    if (from.has_latest_msg_type()) {
      set_latest_msg_type(from.latest_msg_type());
    }
    if (from.has_latest_msg_from_user_id()) {
      set_latest_msg_from_user_id(from.latest_msg_from_user_id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UnreadInfo::CopyFrom(const UnreadInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnreadInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void UnreadInfo::Swap(UnreadInfo* other) {
  if (other != this) {
    std::swap(session_id_, other->session_id_);
    std::swap(session_type_, other->session_type_);
    std::swap(unread_cnt_, other->unread_cnt_);
    std::swap(latest_msg_id_, other->latest_msg_id_);
    std::swap(latest_msg_data_, other->latest_msg_data_);
    std::swap(latest_msg_type_, other->latest_msg_type_);
    std::swap(latest_msg_from_user_id_, other->latest_msg_from_user_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UnreadInfo::GetTypeName() const {
  return "IM.BaseDefine.UnreadInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int MsgInfo::kMsgIdFieldNumber;
const int MsgInfo::kFromSessionIdFieldNumber;
const int MsgInfo::kCreateTimeFieldNumber;
const int MsgInfo::kMsgTypeFieldNumber;
const int MsgInfo::kMsgDataFieldNumber;
#endif  // !_MSC_VER

MsgInfo::MsgInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.MsgInfo)
}

void MsgInfo::InitAsDefaultInstance() {
}

MsgInfo::MsgInfo(const MsgInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.MsgInfo)
}

void MsgInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  msg_id_ = 0u;
  from_session_id_ = 0u;
  create_time_ = 0u;
  msg_type_ = 1;
  msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MsgInfo::~MsgInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.MsgInfo)
  SharedDtor();
}

void MsgInfo::SharedDtor() {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MsgInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MsgInfo& MsgInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

MsgInfo* MsgInfo::default_instance_ = NULL;

MsgInfo* MsgInfo::New() const {
  return new MsgInfo;
}

void MsgInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MsgInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(msg_id_, create_time_);
    msg_type_ = 1;
    if (has_msg_data()) {
      if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        msg_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MsgInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.MsgInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 msg_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &msg_id_)));
          set_has_msg_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_from_session_id;
        break;
      }

      // required uint32 from_session_id = 2;
      case 2: {
        if (tag == 16) {
         parse_from_session_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_session_id_)));
          set_has_from_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_create_time;
        break;
      }

      // required uint32 create_time = 3;
      case 3: {
        if (tag == 24) {
         parse_create_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &create_time_)));
          set_has_create_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_msg_type;
        break;
      }

      // required .IM.BaseDefine.MsgType msg_type = 4;
      case 4: {
        if (tag == 32) {
         parse_msg_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::MsgType_IsValid(value)) {
            set_msg_type(static_cast< ::IM::BaseDefine::MsgType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_msg_data;
        break;
      }

      // required bytes msg_data = 5;
      case 5: {
        if (tag == 42) {
         parse_msg_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.MsgInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.MsgInfo)
  return false;
#undef DO_
}

void MsgInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.MsgInfo)
  // required uint32 msg_id = 1;
  if (has_msg_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->msg_id(), output);
  }

  // required uint32 from_session_id = 2;
  if (has_from_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_session_id(), output);
  }

  // required uint32 create_time = 3;
  if (has_create_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->create_time(), output);
  }

  // required .IM.BaseDefine.MsgType msg_type = 4;
  if (has_msg_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->msg_type(), output);
  }

  // required bytes msg_data = 5;
  if (has_msg_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->msg_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.MsgInfo)
}

int MsgInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 msg_id = 1;
    if (has_msg_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->msg_id());
    }

    // required uint32 from_session_id = 2;
    if (has_from_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_session_id());
    }

    // required uint32 create_time = 3;
    if (has_create_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->create_time());
    }

    // required .IM.BaseDefine.MsgType msg_type = 4;
    if (has_msg_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->msg_type());
    }

    // required bytes msg_data = 5;
    if (has_msg_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->msg_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MsgInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MsgInfo*>(&from));
}

void MsgInfo::MergeFrom(const MsgInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_msg_id()) {
      set_msg_id(from.msg_id());
    }
    if (from.has_from_session_id()) {
      set_from_session_id(from.from_session_id());
    }
    if (from.has_create_time()) {
      set_create_time(from.create_time());
    }
    if (from.has_msg_type()) {
      set_msg_type(from.msg_type());
    }
    if (from.has_msg_data()) {
      set_msg_data(from.msg_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MsgInfo::CopyFrom(const MsgInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MsgInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void MsgInfo::Swap(MsgInfo* other) {
  if (other != this) {
    std::swap(msg_id_, other->msg_id_);
    std::swap(from_session_id_, other->from_session_id_);
    std::swap(create_time_, other->create_time_);
    std::swap(msg_type_, other->msg_type_);
    std::swap(msg_data_, other->msg_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MsgInfo::GetTypeName() const {
  return "IM.BaseDefine.MsgInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupVersionInfo::kGroupIdFieldNumber;
const int GroupVersionInfo::kVersionFieldNumber;
#endif  // !_MSC_VER

GroupVersionInfo::GroupVersionInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.GroupVersionInfo)
}

void GroupVersionInfo::InitAsDefaultInstance() {
}

GroupVersionInfo::GroupVersionInfo(const GroupVersionInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.GroupVersionInfo)
}

void GroupVersionInfo::SharedCtor() {
  _cached_size_ = 0;
  group_id_ = 0u;
  version_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupVersionInfo::~GroupVersionInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.GroupVersionInfo)
  SharedDtor();
}

void GroupVersionInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupVersionInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupVersionInfo& GroupVersionInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

GroupVersionInfo* GroupVersionInfo::default_instance_ = NULL;

GroupVersionInfo* GroupVersionInfo::New() const {
  return new GroupVersionInfo;
}

void GroupVersionInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GroupVersionInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(group_id_, version_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupVersionInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.GroupVersionInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_version;
        break;
      }

      // required uint32 version = 2;
      case 2: {
        if (tag == 16) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.GroupVersionInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.GroupVersionInfo)
  return false;
#undef DO_
}

void GroupVersionInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.GroupVersionInfo)
  // required uint32 group_id = 1;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // required uint32 version = 2;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->version(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.GroupVersionInfo)
}

int GroupVersionInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 group_id = 1;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // required uint32 version = 2;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupVersionInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupVersionInfo*>(&from));
}

void GroupVersionInfo::MergeFrom(const GroupVersionInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupVersionInfo::CopyFrom(const GroupVersionInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupVersionInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GroupVersionInfo::Swap(GroupVersionInfo* other) {
  if (other != this) {
    std::swap(group_id_, other->group_id_);
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupVersionInfo::GetTypeName() const {
  return "IM.BaseDefine.GroupVersionInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int GroupInfo::kGroupIdFieldNumber;
const int GroupInfo::kVersionFieldNumber;
const int GroupInfo::kGroupNameFieldNumber;
const int GroupInfo::kGroupAvatarFieldNumber;
const int GroupInfo::kGroupCreatorIdFieldNumber;
const int GroupInfo::kGroupTypeFieldNumber;
const int GroupInfo::kShieldStatusFieldNumber;
const int GroupInfo::kGroupMemberListFieldNumber;
#endif  // !_MSC_VER

GroupInfo::GroupInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.GroupInfo)
}

void GroupInfo::InitAsDefaultInstance() {
}

GroupInfo::GroupInfo(const GroupInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.GroupInfo)
}

void GroupInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  group_id_ = 0u;
  version_ = 0u;
  group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  group_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  group_creator_id_ = 0u;
  group_type_ = 1;
  shield_status_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroupInfo::~GroupInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.GroupInfo)
  SharedDtor();
}

void GroupInfo::SharedDtor() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_avatar_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GroupInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GroupInfo& GroupInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

GroupInfo* GroupInfo::default_instance_ = NULL;

GroupInfo* GroupInfo::New() const {
  return new GroupInfo;
}

void GroupInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GroupInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(group_id_, version_);
    if (has_group_name()) {
      if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        group_name_->clear();
      }
    }
    if (has_group_avatar()) {
      if (group_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        group_avatar_->clear();
      }
    }
    group_creator_id_ = 0u;
    group_type_ = 1;
    shield_status_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  group_member_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GroupInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.GroupInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_version;
        break;
      }

      // required uint32 version = 2;
      case 2: {
        if (tag == 16) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_group_name;
        break;
      }

      // required string group_name = 3;
      case 3: {
        if (tag == 26) {
         parse_group_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_group_avatar;
        break;
      }

      // required string group_avatar = 4;
      case 4: {
        if (tag == 34) {
         parse_group_avatar:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group_avatar()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_group_creator_id;
        break;
      }

      // required uint32 group_creator_id = 5;
      case 5: {
        if (tag == 40) {
         parse_group_creator_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_creator_id_)));
          set_has_group_creator_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_group_type;
        break;
      }

      // required .IM.BaseDefine.GroupType group_type = 6;
      case 6: {
        if (tag == 48) {
         parse_group_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::GroupType_IsValid(value)) {
            set_group_type(static_cast< ::IM::BaseDefine::GroupType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_shield_status;
        break;
      }

      // required uint32 shield_status = 7;
      case 7: {
        if (tag == 56) {
         parse_shield_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shield_status_)));
          set_has_shield_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_group_member_list;
        break;
      }

      // repeated uint32 group_member_list = 8;
      case 8: {
        if (tag == 64) {
         parse_group_member_list:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 64, input, this->mutable_group_member_list())));
        } else if (tag == 66) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_group_member_list())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_group_member_list;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.GroupInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.GroupInfo)
  return false;
#undef DO_
}

void GroupInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.GroupInfo)
  // required uint32 group_id = 1;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // required uint32 version = 2;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->version(), output);
  }

  // required string group_name = 3;
  if (has_group_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->group_name(), output);
  }

  // required string group_avatar = 4;
  if (has_group_avatar()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->group_avatar(), output);
  }

  // required uint32 group_creator_id = 5;
  if (has_group_creator_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->group_creator_id(), output);
  }

  // required .IM.BaseDefine.GroupType group_type = 6;
  if (has_group_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->group_type(), output);
  }

  // required uint32 shield_status = 7;
  if (has_shield_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->shield_status(), output);
  }

  // repeated uint32 group_member_list = 8;
  for (int i = 0; i < this->group_member_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      8, this->group_member_list(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.GroupInfo)
}

int GroupInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 group_id = 1;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // required uint32 version = 2;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // required string group_name = 3;
    if (has_group_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group_name());
    }

    // required string group_avatar = 4;
    if (has_group_avatar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group_avatar());
    }

    // required uint32 group_creator_id = 5;
    if (has_group_creator_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_creator_id());
    }

    // required .IM.BaseDefine.GroupType group_type = 6;
    if (has_group_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->group_type());
    }

    // required uint32 shield_status = 7;
    if (has_shield_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shield_status());
    }

  }
  // repeated uint32 group_member_list = 8;
  {
    int data_size = 0;
    for (int i = 0; i < this->group_member_list_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->group_member_list(i));
    }
    total_size += 1 * this->group_member_list_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroupInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GroupInfo*>(&from));
}

void GroupInfo::MergeFrom(const GroupInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  group_member_list_.MergeFrom(from.group_member_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_group_name()) {
      set_group_name(from.group_name());
    }
    if (from.has_group_avatar()) {
      set_group_avatar(from.group_avatar());
    }
    if (from.has_group_creator_id()) {
      set_group_creator_id(from.group_creator_id());
    }
    if (from.has_group_type()) {
      set_group_type(from.group_type());
    }
    if (from.has_shield_status()) {
      set_shield_status(from.shield_status());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GroupInfo::CopyFrom(const GroupInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroupInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000007f) != 0x0000007f) return false;

  return true;
}

void GroupInfo::Swap(GroupInfo* other) {
  if (other != this) {
    std::swap(group_id_, other->group_id_);
    std::swap(version_, other->version_);
    std::swap(group_name_, other->group_name_);
    std::swap(group_avatar_, other->group_avatar_);
    std::swap(group_creator_id_, other->group_creator_id_);
    std::swap(group_type_, other->group_type_);
    std::swap(shield_status_, other->shield_status_);
    group_member_list_.Swap(&other->group_member_list_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GroupInfo::GetTypeName() const {
  return "IM.BaseDefine.GroupInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int UserTokenInfo::kUserIdFieldNumber;
const int UserTokenInfo::kUserTypeFieldNumber;
const int UserTokenInfo::kTokenFieldNumber;
const int UserTokenInfo::kPushCountFieldNumber;
const int UserTokenInfo::kPushTypeFieldNumber;
#endif  // !_MSC_VER

UserTokenInfo::UserTokenInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.UserTokenInfo)
}

void UserTokenInfo::InitAsDefaultInstance() {
}

UserTokenInfo::UserTokenInfo(const UserTokenInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.UserTokenInfo)
}

void UserTokenInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_id_ = 0u;
  user_type_ = 1;
  token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  push_count_ = 0u;
  push_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UserTokenInfo::~UserTokenInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.UserTokenInfo)
  SharedDtor();
}

void UserTokenInfo::SharedDtor() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UserTokenInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UserTokenInfo& UserTokenInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

UserTokenInfo* UserTokenInfo::default_instance_ = NULL;

UserTokenInfo* UserTokenInfo::New() const {
  return new UserTokenInfo;
}

void UserTokenInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<UserTokenInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(push_count_, push_type_);
    user_id_ = 0u;
    user_type_ = 1;
    if (has_token()) {
      if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        token_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UserTokenInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.UserTokenInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_user_type;
        break;
      }

      // required .IM.BaseDefine.ClientType user_type = 2;
      case 2: {
        if (tag == 16) {
         parse_user_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_user_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_token;
        break;
      }

      // required string token = 3;
      case 3: {
        if (tag == 26) {
         parse_token:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_token()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_push_count;
        break;
      }

      // required uint32 push_count = 4;
      case 4: {
        if (tag == 32) {
         parse_push_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &push_count_)));
          set_has_push_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_push_type;
        break;
      }

      // required uint32 push_type = 5;
      case 5: {
        if (tag == 40) {
         parse_push_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &push_type_)));
          set_has_push_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.UserTokenInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.UserTokenInfo)
  return false;
#undef DO_
}

void UserTokenInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.UserTokenInfo)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required .IM.BaseDefine.ClientType user_type = 2;
  if (has_user_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->user_type(), output);
  }

  // required string token = 3;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->token(), output);
  }

  // required uint32 push_count = 4;
  if (has_push_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->push_count(), output);
  }

  // required uint32 push_type = 5;
  if (has_push_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->push_type(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.UserTokenInfo)
}

int UserTokenInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required .IM.BaseDefine.ClientType user_type = 2;
    if (has_user_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->user_type());
    }

    // required string token = 3;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->token());
    }

    // required uint32 push_count = 4;
    if (has_push_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->push_count());
    }

    // required uint32 push_type = 5;
    if (has_push_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->push_type());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UserTokenInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UserTokenInfo*>(&from));
}

void UserTokenInfo::MergeFrom(const UserTokenInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_user_type()) {
      set_user_type(from.user_type());
    }
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_push_count()) {
      set_push_count(from.push_count());
    }
    if (from.has_push_type()) {
      set_push_type(from.push_type());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UserTokenInfo::CopyFrom(const UserTokenInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserTokenInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void UserTokenInfo::Swap(UserTokenInfo* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(user_type_, other->user_type_);
    std::swap(token_, other->token_);
    std::swap(push_count_, other->push_count_);
    std::swap(push_type_, other->push_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UserTokenInfo::GetTypeName() const {
  return "IM.BaseDefine.UserTokenInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int PushResult::kUserTokenFieldNumber;
const int PushResult::kResultCodeFieldNumber;
#endif  // !_MSC_VER

PushResult::PushResult()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.PushResult)
}

void PushResult::InitAsDefaultInstance() {
}

PushResult::PushResult(const PushResult& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.PushResult)
}

void PushResult::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  result_code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PushResult::~PushResult() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.PushResult)
  SharedDtor();
}

void PushResult::SharedDtor() {
  if (user_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_token_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PushResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PushResult& PushResult::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

PushResult* PushResult::default_instance_ = NULL;

PushResult* PushResult::New() const {
  return new PushResult;
}

void PushResult::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_user_token()) {
      if (user_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        user_token_->clear();
      }
    }
    result_code_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool PushResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.PushResult)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_token = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_token()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_result_code;
        break;
      }

      // required uint32 result_code = 2;
      case 2: {
        if (tag == 16) {
         parse_result_code:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
          set_has_result_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.PushResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.PushResult)
  return false;
#undef DO_
}

void PushResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.PushResult)
  // required string user_token = 1;
  if (has_user_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->user_token(), output);
  }

  // required uint32 result_code = 2;
  if (has_result_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->result_code(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.PushResult)
}

int PushResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string user_token = 1;
    if (has_user_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user_token());
    }

    // required uint32 result_code = 2;
    if (has_result_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->result_code());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushResult::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PushResult*>(&from));
}

void PushResult::MergeFrom(const PushResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_token()) {
      set_user_token(from.user_token());
    }
    if (from.has_result_code()) {
      set_result_code(from.result_code());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void PushResult::CopyFrom(const PushResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushResult::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PushResult::Swap(PushResult* other) {
  if (other != this) {
    std::swap(user_token_, other->user_token_);
    std::swap(result_code_, other->result_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string PushResult::GetTypeName() const {
  return "IM.BaseDefine.PushResult";
}


// ===================================================================

#ifndef _MSC_VER
const int ShieldStatus::kUserIdFieldNumber;
const int ShieldStatus::kGroupIdFieldNumber;
const int ShieldStatus::kShieldStatusFieldNumber;
#endif  // !_MSC_VER

ShieldStatus::ShieldStatus()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.ShieldStatus)
}

void ShieldStatus::InitAsDefaultInstance() {
}

ShieldStatus::ShieldStatus(const ShieldStatus& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.ShieldStatus)
}

void ShieldStatus::SharedCtor() {
  _cached_size_ = 0;
  user_id_ = 0u;
  group_id_ = 0u;
  shield_status_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShieldStatus::~ShieldStatus() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.ShieldStatus)
  SharedDtor();
}

void ShieldStatus::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ShieldStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ShieldStatus& ShieldStatus::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

ShieldStatus* ShieldStatus::default_instance_ = NULL;

ShieldStatus* ShieldStatus::New() const {
  return new ShieldStatus;
}

void ShieldStatus::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ShieldStatus*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(user_id_, shield_status_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool ShieldStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.ShieldStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_group_id;
        break;
      }

      // required uint32 group_id = 2;
      case 2: {
        if (tag == 16) {
         parse_group_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_shield_status;
        break;
      }

      // required uint32 shield_status = 3;
      case 3: {
        if (tag == 24) {
         parse_shield_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shield_status_)));
          set_has_shield_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.ShieldStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.ShieldStatus)
  return false;
#undef DO_
}

void ShieldStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.ShieldStatus)
  // required uint32 user_id = 1;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 group_id = 2;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->group_id(), output);
  }

  // required uint32 shield_status = 3;
  if (has_shield_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->shield_status(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.ShieldStatus)
}

int ShieldStatus::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 user_id = 1;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->user_id());
    }

    // required uint32 group_id = 2;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // required uint32 shield_status = 3;
    if (has_shield_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shield_status());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ShieldStatus::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ShieldStatus*>(&from));
}

void ShieldStatus::MergeFrom(const ShieldStatus& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_shield_status()) {
      set_shield_status(from.shield_status());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void ShieldStatus::CopyFrom(const ShieldStatus& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShieldStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ShieldStatus::Swap(ShieldStatus* other) {
  if (other != this) {
    std::swap(user_id_, other->user_id_);
    std::swap(group_id_, other->group_id_);
    std::swap(shield_status_, other->shield_status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string ShieldStatus::GetTypeName() const {
  return "IM.BaseDefine.ShieldStatus";
}


// ===================================================================

#ifndef _MSC_VER
const int OfflineFileInfo::kFromUserIdFieldNumber;
const int OfflineFileInfo::kTaskIdFieldNumber;
const int OfflineFileInfo::kFileNameFieldNumber;
const int OfflineFileInfo::kFileSizeFieldNumber;
const int OfflineFileInfo::kIpAddrListFieldNumber;
const int OfflineFileInfo::kSendTimeFieldNumber;
#endif  // !_MSC_VER

OfflineFileInfo::OfflineFileInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.OfflineFileInfo)
}

void OfflineFileInfo::InitAsDefaultInstance() {
}

OfflineFileInfo::OfflineFileInfo(const OfflineFileInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.OfflineFileInfo)
}

void OfflineFileInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  from_user_id_ = 0u;
  task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_size_ = 0u;
  send_time_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OfflineFileInfo::~OfflineFileInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.OfflineFileInfo)
  SharedDtor();
}

void OfflineFileInfo::SharedDtor() {
  if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete task_id_;
  }
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OfflineFileInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OfflineFileInfo& OfflineFileInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

OfflineFileInfo* OfflineFileInfo::default_instance_ = NULL;

OfflineFileInfo* OfflineFileInfo::New() const {
  return new OfflineFileInfo;
}

void OfflineFileInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<OfflineFileInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 47) {
    ZR_(from_user_id_, file_size_);
    if (has_task_id()) {
      if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        task_id_->clear();
      }
    }
    if (has_file_name()) {
      if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        file_name_->clear();
      }
    }
    send_time_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ip_addr_list_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool OfflineFileInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.OfflineFileInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_user_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
          set_has_from_user_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_task_id;
        break;
      }

      // required string task_id = 2;
      case 2: {
        if (tag == 18) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_file_name;
        break;
      }

      // required string file_name = 3;
      case 3: {
        if (tag == 26) {
         parse_file_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_file_size;
        break;
      }

      // required uint32 file_size = 4;
      case 4: {
        if (tag == 32) {
         parse_file_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_size_)));
          set_has_file_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_ip_addr_list;
        break;
      }

      // repeated .IM.BaseDefine.IpAddr ip_addr_list = 10;
      case 10: {
        if (tag == 82) {
         parse_ip_addr_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ip_addr_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_ip_addr_list;
        if (input->ExpectTag(88)) goto parse_send_time;
        break;
      }

      // optional uint32 send_time = 11;
      case 11: {
        if (tag == 88) {
         parse_send_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &send_time_)));
          set_has_send_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.OfflineFileInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.OfflineFileInfo)
  return false;
#undef DO_
}

void OfflineFileInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.OfflineFileInfo)
  // required uint32 from_user_id = 1;
  if (has_from_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_user_id(), output);
  }

  // required string task_id = 2;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->task_id(), output);
  }

  // required string file_name = 3;
  if (has_file_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->file_name(), output);
  }

  // required uint32 file_size = 4;
  if (has_file_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->file_size(), output);
  }

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 10;
  for (int i = 0; i < this->ip_addr_list_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, this->ip_addr_list(i), output);
  }

  // optional uint32 send_time = 11;
  if (has_send_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->send_time(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.OfflineFileInfo)
}

int OfflineFileInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 from_user_id = 1;
    if (has_from_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->from_user_id());
    }

    // required string task_id = 2;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }

    // required string file_name = 3;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }

    // required uint32 file_size = 4;
    if (has_file_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_size());
    }

    // optional uint32 send_time = 11;
    if (has_send_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->send_time());
    }

  }
  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 10;
  total_size += 1 * this->ip_addr_list_size();
  for (int i = 0; i < this->ip_addr_list_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ip_addr_list(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OfflineFileInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OfflineFileInfo*>(&from));
}

void OfflineFileInfo::MergeFrom(const OfflineFileInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  ip_addr_list_.MergeFrom(from.ip_addr_list_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_from_user_id()) {
      set_from_user_id(from.from_user_id());
    }
    if (from.has_task_id()) {
      set_task_id(from.task_id());
    }
    if (from.has_file_name()) {
      set_file_name(from.file_name());
    }
    if (from.has_file_size()) {
      set_file_size(from.file_size());
    }
    if (from.has_send_time()) {
      set_send_time(from.send_time());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void OfflineFileInfo::CopyFrom(const OfflineFileInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfflineFileInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->ip_addr_list())) return false;
  return true;
}

void OfflineFileInfo::Swap(OfflineFileInfo* other) {
  if (other != this) {
    std::swap(from_user_id_, other->from_user_id_);
    std::swap(task_id_, other->task_id_);
    std::swap(file_name_, other->file_name_);
    std::swap(file_size_, other->file_size_);
    ip_addr_list_.Swap(&other->ip_addr_list_);
    std::swap(send_time_, other->send_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OfflineFileInfo::GetTypeName() const {
  return "IM.BaseDefine.OfflineFileInfo";
}


// ===================================================================

#ifndef _MSC_VER
const int DepartInfo::kGroupIdFieldNumber;
const int DepartInfo::kGroupFlagFieldNumber;
const int DepartInfo::kGroupNameFieldNumber;
const int DepartInfo::kGroupSortFieldNumber;
#endif  // !_MSC_VER

DepartInfo::DepartInfo()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.BaseDefine.DepartInfo)
}

void DepartInfo::InitAsDefaultInstance() {
}

DepartInfo::DepartInfo(const DepartInfo& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:IM.BaseDefine.DepartInfo)
}

void DepartInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  group_id_ = 0u;
  group_flag_ = 0u;
  group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  group_sort_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DepartInfo::~DepartInfo() {
  // @@protoc_insertion_point(destructor:IM.BaseDefine.DepartInfo)
  SharedDtor();
}

void DepartInfo::SharedDtor() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DepartInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DepartInfo& DepartInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_IM_2eBaseDefine_2eproto();
#endif
  return *default_instance_;
}

DepartInfo* DepartInfo::default_instance_ = NULL;

DepartInfo* DepartInfo::New() const {
  return new DepartInfo;
}

void DepartInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<DepartInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(group_id_, group_flag_);
    if (has_group_name()) {
      if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        group_name_->clear();
      }
    }
    group_sort_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool DepartInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:IM.BaseDefine.DepartInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
          set_has_group_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_group_flag;
        break;
      }

      // required uint32 group_flag = 2;
      case 2: {
        if (tag == 16) {
         parse_group_flag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_flag_)));
          set_has_group_flag();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_group_name;
        break;
      }

      // required string group_name = 3;
      case 3: {
        if (tag == 26) {
         parse_group_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_group_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_group_sort;
        break;
      }

      // required uint32 group_sort = 4;
      case 4: {
        if (tag == 32) {
         parse_group_sort:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_sort_)));
          set_has_group_sort();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.BaseDefine.DepartInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.BaseDefine.DepartInfo)
  return false;
#undef DO_
}

void DepartInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.BaseDefine.DepartInfo)
  // required uint32 group_id = 1;
  if (has_group_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // required uint32 group_flag = 2;
  if (has_group_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->group_flag(), output);
  }

  // required string group_name = 3;
  if (has_group_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->group_name(), output);
  }

  // required uint32 group_sort = 4;
  if (has_group_sort()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->group_sort(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:IM.BaseDefine.DepartInfo)
}

int DepartInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 group_id = 1;
    if (has_group_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_id());
    }

    // required uint32 group_flag = 2;
    if (has_group_flag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_flag());
    }

    // required string group_name = 3;
    if (has_group_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->group_name());
    }

    // required uint32 group_sort = 4;
    if (has_group_sort()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->group_sort());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DepartInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DepartInfo*>(&from));
}

void DepartInfo::MergeFrom(const DepartInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_group_id()) {
      set_group_id(from.group_id());
    }
    if (from.has_group_flag()) {
      set_group_flag(from.group_flag());
    }
    if (from.has_group_name()) {
      set_group_name(from.group_name());
    }
    if (from.has_group_sort()) {
      set_group_sort(from.group_sort());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void DepartInfo::CopyFrom(const DepartInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DepartInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void DepartInfo::Swap(DepartInfo* other) {
  if (other != this) {
    std::swap(group_id_, other->group_id_);
    std::swap(group_flag_, other->group_flag_);
    std::swap(group_name_, other->group_name_);
    std::swap(group_sort_, other->group_sort_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string DepartInfo::GetTypeName() const {
  return "IM.BaseDefine.DepartInfo";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace BaseDefine
}  // namespace IM

// @@protoc_insertion_point(global_scope)
