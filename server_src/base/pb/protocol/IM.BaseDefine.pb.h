// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.BaseDefine.proto

#ifndef PROTOBUF_IM_2eBaseDefine_2eproto__INCLUDED
#define PROTOBUF_IM_2eBaseDefine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace IM {
namespace BaseDefine {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

class IpAddr;
class UserInfo;
class ContactSessionInfo;
class UserStat;
class UnreadInfo;
class MsgInfo;
class GroupVersionInfo;
class GroupInfo;
class UserTokenInfo;
class PushResult;
class ShieldStatus;
class OfflineFileInfo;
class DepartInfo;

enum ServiceID {
  DFFX_SID_LOGIN = 1,
  DFFX_SID_BUDDY_LIST = 2,
  DFFX_SID_MSG = 3,
  DFFX_SID_GROUP = 4,
  DFFX_SID_FILE = 5,
  DFFX_SID_SWITCH_SERVICE = 6,
  DFFX_SID_OTHER = 7,
  DFFX_SID_INTERNAL = 8
};
bool ServiceID_IsValid(int value);
const ServiceID ServiceID_MIN = DFFX_SID_LOGIN;
const ServiceID ServiceID_MAX = DFFX_SID_INTERNAL;
const int ServiceID_ARRAYSIZE = ServiceID_MAX + 1;

enum LoginCmdID {
  DFFX_CID_LOGIN_REQ_MSGSERVER = 257,
  DFFX_CID_LOGIN_RES_MSGSERVER = 258,
  DFFX_CID_LOGIN_REQ_USERLOGIN = 259,
  DFFX_CID_LOGIN_RES_USERLOGIN = 260,
  DFFX_CID_LOGIN_REQ_LOGINOUT = 261,
  DFFX_CID_LOGIN_RES_LOGINOUT = 262,
  DFFX_CID_LOGIN_KICK_USER = 263,
  DFFX_CID_LOGIN_REQ_DEVICETOKEN = 264,
  DFFX_CID_LOGIN_RES_DEVICETOKEN = 265,
  DFFX_CID_LOGIN_REQ_KICKPCCLIENT = 266,
  DFFX_CID_LOGIN_RES_KICKPCCLIENT = 267
};
bool LoginCmdID_IsValid(int value);
const LoginCmdID LoginCmdID_MIN = DFFX_CID_LOGIN_REQ_MSGSERVER;
const LoginCmdID LoginCmdID_MAX = DFFX_CID_LOGIN_RES_KICKPCCLIENT;
const int LoginCmdID_ARRAYSIZE = LoginCmdID_MAX + 1;

enum BuddyListCmdID {
  DFFX_CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST = 513,
  DFFX_CID_BUDDY_LIST_RECENT_CONTACT_SESSION_RESPONSE = 514,
  DFFX_CID_BUDDY_LIST_STATUS_NOTIFY = 515,
  DFFX_CID_BUDDY_LIST_USER_INFO_REQUEST = 516,
  DFFX_CID_BUDDY_LIST_USER_INFO_RESPONSE = 517,
  DFFX_CID_BUDDY_LIST_REMOVE_SESSION_REQ = 518,
  DFFX_CID_BUDDY_LIST_REMOVE_SESSION_RES = 519,
  DFFX_CID_BUDDY_LIST_ALL_USER_REQUEST = 520,
  DFFX_CID_BUDDY_LIST_ALL_USER_RESPONSE = 521,
  DFFX_CID_BUDDY_LIST_USERS_STATUS_REQUEST = 522,
  DFFX_CID_BUDDY_LIST_USERS_STATUS_RESPONSE = 523,
  DFFX_CID_BUDDY_LIST_CHANGE_AVATAR_REQUEST = 524,
  DFFX_CID_BUDDY_LIST_CHANGE_AVATAR_RESPONSE = 525,
  DFFX_CID_BUDDY_LIST_PC_LOGIN_STATUS_NOTIFY = 526,
  DFFX_CID_BUDDY_LIST_REMOVE_SESSION_NOTIFY = 527,
  DFFX_CID_BUDDY_LIST_DEPARTMENT_REQUEST = 528,
  DFFX_CID_BUDDY_LIST_DEPARTMENT_RESPONSE = 529,
  DFFX_CID_BUDDY_LIST_ADDFRIEND_REQ = 530,
  DFFX_CID_BUDDY_LIST_ADDFRIEND_RES = 531,
  DFFX_CID_BUDDY_LIST_REVERSEADDFRIEND_REQ = 532,
  DFFX_CID_BUDDY_LIST_REVERSEADDFRIEND_RES = 533,
  DFFX_CID_BUDDY_LIST_DELFRIEND_REQ = 534,
  DFFX_CID_BUDDY_LIST_DELFRIEND_RES = 535,
  DFFX_CID_BUDDY_LIST_CHGFRIENDREMARK_REQ = 536,
  DFFX_CID_BUDDY_LIST_CHGFRIENDREMARK_RES = 537,
  DFFX_CID_BUDDY_LIST_CREATEFRIENDGROUP_REQ = 538,
  DFFX_CID_BUDDY_LIST_CREATEFRIENDGROUP_RES = 539,
  DFFX_CID_BUDDY_LIST_DELFRIENDGROUP_REQ = 540,
  DFFX_CID_BUDDY_LIST_DELFRIENDGROUP_RES = 541,
  DFFX_CID_BUDDY_LIST_MOVEFRIENDTOGROUP_REQ = 542,
  DFFX_CID_BUDDY_LIST_MOVEFRIENDTOGROUP_RES = 543,
  DFFX_CID_BUDDY_LIST_CHGFRIENDGROUPNAME_REQ = 544,
  DFFX_CID_BUDDY_LIST_CHGFRIENDGROUPNAME_RES = 545,
  DFFX_CID_BUDDY_LIST_FRIENDNOTIFY_REQ = 546,
  DFFX_CID_BUDDY_LIST_FRIENDNOTIFY_RES = 547,
  DFFX_CID_BUDDY_LIST_GETADDFRIEND_REQ = 548,
  DFFX_CID_BUDDY_LIST_GETADDFRIEND_RES = 549,
  DFFX_CID_BUDDY_LIST_FINDUSERINFO_REQ = 550,
  DFFX_CID_BUDDY_LIST_FINDUSERINFO_RES = 551,
  DFFX_CID_BUDDY_LIST_DELFRIEND_NOTIFY = 552
};
bool BuddyListCmdID_IsValid(int value);
const BuddyListCmdID BuddyListCmdID_MIN = DFFX_CID_BUDDY_LIST_RECENT_CONTACT_SESSION_REQUEST;
const BuddyListCmdID BuddyListCmdID_MAX = DFFX_CID_BUDDY_LIST_DELFRIEND_NOTIFY;
const int BuddyListCmdID_ARRAYSIZE = BuddyListCmdID_MAX + 1;

enum MessageCmdID {
  DFFX_CID_MSG_DATA = 769,
  DFFX_CID_MSG_DATA_ACK = 770,
  DFFX_CID_MSG_READ_ACK = 771,
  DFFX_CID_MSG_READ_NOTIFY = 772,
  DFFX_CID_MSG_TIME_REQUEST = 773,
  DFFX_CID_MSG_TIME_RESPONSE = 774,
  DFFX_CID_MSG_UNREAD_CNT_REQUEST = 775,
  DFFX_CID_MSG_UNREAD_CNT_RESPONSE = 776,
  DFFX_CID_MSG_LIST_REQUEST = 777,
  DFFX_CID_MSG_LIST_RESPONSE = 778,
  DFFX_CID_MSG_GET_LATEST_MSG_ID_REQ = 779,
  DFFX_CID_MSG_GET_LATEST_MSG_ID_RSP = 780,
  DFFX_CID_MSG_GET_BY_MSG_ID_REQ = 781,
  DFFX_CID_MSG_GET_BY_MSG_ID_RES = 782,
  DFFX_CID_MSG_CLEAN_MSGLIST_REQ = 783,
  DFFX_CID_MSG_CLEAN_MSGLIST_RES = 784,
  DFFX_CID_MSG_ORDERSTATUS_READ = 785,
  DFFX_CID_MSG_ORDERSTATUS_READ_BROADCAST = 786
};
bool MessageCmdID_IsValid(int value);
const MessageCmdID MessageCmdID_MIN = DFFX_CID_MSG_DATA;
const MessageCmdID MessageCmdID_MAX = DFFX_CID_MSG_ORDERSTATUS_READ_BROADCAST;
const int MessageCmdID_ARRAYSIZE = MessageCmdID_MAX + 1;

enum GroupCmdID {
  DFFX_CID_GROUP_NORMAL_LIST_REQUEST = 1025,
  DFFX_CID_GROUP_NORMAL_LIST_RESPONSE = 1026,
  DFFX_CID_GROUP_INFO_REQUEST = 1027,
  DFFX_CID_GROUP_INFO_RESPONSE = 1028,
  DFFX_CID_GROUP_CREATE_REQUEST = 1029,
  DFFX_CID_GROUP_CREATE_RESPONSE = 1030,
  DFFX_CID_GROUP_CHANGE_MEMBER_REQUEST = 1031,
  DFFX_CID_GROUP_CHANGE_MEMBER_RESPONSE = 1032,
  DFFX_CID_GROUP_SHIELD_GROUP_REQUEST = 1033,
  DFFX_CID_GROUP_SHIELD_GROUP_RESPONSE = 1034,
  DFFX_CID_GROUP_CHANGE_MEMBER_NOTIFY = 1035
};
bool GroupCmdID_IsValid(int value);
const GroupCmdID GroupCmdID_MIN = DFFX_CID_GROUP_NORMAL_LIST_REQUEST;
const GroupCmdID GroupCmdID_MAX = DFFX_CID_GROUP_CHANGE_MEMBER_NOTIFY;
const int GroupCmdID_ARRAYSIZE = GroupCmdID_MAX + 1;

enum FileCmdID {
  DFFX_CID_FILE_LOGIN_REQ = 1281,
  DFFX_CID_FILE_LOGIN_RES = 1282,
  DFFX_CID_FILE_STATE = 1283,
  DFFX_CID_FILE_PULL_DATA_REQ = 1284,
  DFFX_CID_FILE_PULL_DATA_RSP = 1285,
  DFFX_CID_FILE_REQUEST = 1286,
  DFFX_CID_FILE_RESPONSE = 1287,
  DFFX_CID_FILE_NOTIFY = 1288,
  DFFX_CID_FILE_HAS_OFFLINE_REQ = 1289,
  DFFX_CID_FILE_HAS_OFFLINE_RES = 1290,
  DFFX_CID_FILE_ADD_OFFLINE_REQ = 1291,
  DFFX_CID_FILE_DEL_OFFLINE_REQ = 1292
};
bool FileCmdID_IsValid(int value);
const FileCmdID FileCmdID_MIN = DFFX_CID_FILE_LOGIN_REQ;
const FileCmdID FileCmdID_MAX = DFFX_CID_FILE_DEL_OFFLINE_REQ;
const int FileCmdID_ARRAYSIZE = FileCmdID_MAX + 1;

enum SwitchServiceCmdID {
  DFFX_CID_SWITCH_P2P_CMD = 1537
};
bool SwitchServiceCmdID_IsValid(int value);
const SwitchServiceCmdID SwitchServiceCmdID_MIN = DFFX_CID_SWITCH_P2P_CMD;
const SwitchServiceCmdID SwitchServiceCmdID_MAX = DFFX_CID_SWITCH_P2P_CMD;
const int SwitchServiceCmdID_ARRAYSIZE = SwitchServiceCmdID_MAX + 1;

enum OtherCmdID {
  DFFX_CID_OTHER_HEARTBEAT = 1793
};
bool OtherCmdID_IsValid(int value);
const OtherCmdID OtherCmdID_MIN = DFFX_CID_OTHER_HEARTBEAT;
const OtherCmdID OtherCmdID_MAX = DFFX_CID_OTHER_HEARTBEAT;
const int OtherCmdID_ARRAYSIZE = OtherCmdID_MAX + 1;

enum InternalCmdId {
  DFFX_CID_OTHER_STOP_RECV_PACKET = 2050,
  DFFX_CID_OTHER_VALIDATE_REQ = 2051,
  DFFX_CID_OTHER_VALIDATE_RSP = 2052,
  DFFX_CID_OTHER_GET_DEVICE_TOKEN_REQ = 2053,
  DFFX_CID_OTHER_GET_DEVICE_TOKEN_RSP = 2054,
  DFFX_CID_OTHER_ROLE_SET = 2055,
  DFFX_CID_OTHER_ONLINE_USER_INFO = 2056,
  DFFX_CID_OTHER_MSG_SERV_INFO = 2057,
  DFFX_CID_OTHER_USER_STATUS_UPDATE = 2058,
  DFFX_CID_OTHER_USER_CNT_UPDATE = 2059,
  DFFX_CID_OTHER_SERVER_KICK_USER = 2061,
  DFFX_CID_OTHER_LOGIN_STATUS_NOTIFY = 2062,
  DFFX_CID_OTHER_PUSH_TO_USER_REQ = 2063,
  DFFX_CID_OTHER_PUSH_TO_USER_RSP = 2064,
  DFFX_CID_OTHER_GET_SHIELD_REQ = 2065,
  DFFX_CID_OTHER_GET_SHIELD_RSP = 2066,
  DFFX_CID_OTHER_FILE_TRANSFER_REQ = 2067,
  DFFX_CID_OTHER_FILE_TRANSFER_RSP = 2068,
  DFFX_CID_OTHER_FILE_SERVER_IP_REQ = 2069,
  DFFX_CID_OTHER_FILE_SERVER_IP_RSP = 2070,
  DFFX_CID_OTHER_GETFRIENDSID_REQ = 2071,
  DFFX_CID_OTHER_GETFRIENDSID_RES = 2072,
  DFFX_CID_OTHER_MSGSRVRESTART_NOTIFY = 2073
};
bool InternalCmdId_IsValid(int value);
const InternalCmdId InternalCmdId_MIN = DFFX_CID_OTHER_STOP_RECV_PACKET;
const InternalCmdId InternalCmdId_MAX = DFFX_CID_OTHER_MSGSRVRESTART_NOTIFY;
const int InternalCmdId_ARRAYSIZE = InternalCmdId_MAX + 1;

enum OrderMsgStatus {
  CONSULT_DOCUMENTS_GRAB = 0,
  LAWSUIT_ATTENDANCE_GRAB = 1,
  GRAB_SUCCESS = 2,
  GRAB_FAID = 3,
  ENTRUST_ACCEPT = 4,
  ENTRUST_CANCEL = 5,
  TOPUP_SUCCESS = 6,
  TOPUP_FAILED = 7,
  BWITHDRAWAL_SUCCESS = 8,
  BWITHDRAWAL_FAILED = 9,
  TWITHDRAWAL_SUCCESS = 10,
  TWITHDRAWAL_FAILED = 11,
  CHECK_SUCCESS = 12,
  CHECK_FAILED = 13,
  USER_CANCEL = 14,
  VALID_CANCEL = 15,
  ORDER_COMPLETE = 16,
  ORDER_REVOKE = 17
};
bool OrderMsgStatus_IsValid(int value);
const OrderMsgStatus OrderMsgStatus_MIN = CONSULT_DOCUMENTS_GRAB;
const OrderMsgStatus OrderMsgStatus_MAX = ORDER_REVOKE;
const int OrderMsgStatus_ARRAYSIZE = OrderMsgStatus_MAX + 1;

enum ResultType {
  REFUSE_REASON_NONE = 0,
  REFUSE_REASON_NO_MSG_SERVER = 1,
  REFUSE_REASON_MSG_SERVER_FULL = 2,
  REFUSE_REASON_NO_DB_SERVER = 3,
  REFUSE_REASON_NO_LOGIN_SERVER = 4,
  REFUSE_REASON_NO_ROUTE_SERVER = 5,
  REFUSE_REASON_DB_VALIDATE_FAILED = 6,
  REFUSE_REASON_VERSION_TOO_OLD = 7
};
bool ResultType_IsValid(int value);
const ResultType ResultType_MIN = REFUSE_REASON_NONE;
const ResultType ResultType_MAX = REFUSE_REASON_VERSION_TOO_OLD;
const int ResultType_ARRAYSIZE = ResultType_MAX + 1;

enum KickReasonType {
  KICK_REASON_DUPLICATE_USER = 1,
  KICK_REASON_MOBILE_KICK = 2
};
bool KickReasonType_IsValid(int value);
const KickReasonType KickReasonType_MIN = KICK_REASON_DUPLICATE_USER;
const KickReasonType KickReasonType_MAX = KICK_REASON_MOBILE_KICK;
const int KickReasonType_ARRAYSIZE = KickReasonType_MAX + 1;

enum UserStatType {
  USER_STATUS_ONLINE = 1,
  USER_STATUS_OFFLINE = 2,
  USER_STATUS_LEAVE = 3
};
bool UserStatType_IsValid(int value);
const UserStatType UserStatType_MIN = USER_STATUS_ONLINE;
const UserStatType UserStatType_MAX = USER_STATUS_LEAVE;
const int UserStatType_ARRAYSIZE = UserStatType_MAX + 1;

enum SessionType {
  SESSION_TYPE_SINGLE = 1,
  SESSION_TYPE_GROUP = 2
};
bool SessionType_IsValid(int value);
const SessionType SessionType_MIN = SESSION_TYPE_SINGLE;
const SessionType SessionType_MAX = SESSION_TYPE_GROUP;
const int SessionType_ARRAYSIZE = SessionType_MAX + 1;

enum MsgType {
  MSG_TYPE_SINGLE_TEXT = 1,
  MSG_TYPE_SINGLE_AUDIO = 2,
  MSG_TYPE_GROUP_TEXT = 17,
  MSG_TYPE_GROUP_AUDIO = 18,
  MSG_TYPE_ORDER_PUSH = 33,
  MSG_TYPE_ORDER_GRAB = 34,
  MSG_TYPE_ORDER_RESULT = 35,
  MSG_TYPE_ORDER_ENTRUST = 36,
  MSG_TYPE_ORDER_ACCEPT = 37,
  MSG_TYPE_ORDER_CANCEL = 38,
  MSG_TYPE_TOPUP_WITHDRAWAL = 39,
  MSG_TYPE_USER_CHECK = 40,
  MSG_TYPE_ORDER_WAITPAYMENT = 41,
  MSG_TYPE_ORDER_ALLCANCEL = 42,
  MSG_TYPE_LOCATION_SHARING = 49,
  MSG_TYPE_FILE_TRANSFER = 50
};
bool MsgType_IsValid(int value);
const MsgType MsgType_MIN = MSG_TYPE_SINGLE_TEXT;
const MsgType MsgType_MAX = MSG_TYPE_FILE_TRANSFER;
const int MsgType_ARRAYSIZE = MsgType_MAX + 1;

enum ClientType {
  CLIENT_TYPE_WINDOWS = 1,
  CLIENT_TYPE_MAC = 2,
  CLIENT_TYPE_IOS = 17,
  CLIENT_TYPE_ANDROID = 18
};
bool ClientType_IsValid(int value);
const ClientType ClientType_MIN = CLIENT_TYPE_WINDOWS;
const ClientType ClientType_MAX = CLIENT_TYPE_ANDROID;
const int ClientType_ARRAYSIZE = ClientType_MAX + 1;

enum GroupType {
  GROUP_TYPE_NORMAL = 1,
  GROUP_TYPE_TMP = 2
};
bool GroupType_IsValid(int value);
const GroupType GroupType_MIN = GROUP_TYPE_NORMAL;
const GroupType GroupType_MAX = GROUP_TYPE_TMP;
const int GroupType_ARRAYSIZE = GroupType_MAX + 1;

enum GroupModifyType {
  GROUP_MODIFY_TYPE_ADD = 1,
  GROUP_MODIFY_TYPE_DEL = 2
};
bool GroupModifyType_IsValid(int value);
const GroupModifyType GroupModifyType_MIN = GROUP_MODIFY_TYPE_ADD;
const GroupModifyType GroupModifyType_MAX = GROUP_MODIFY_TYPE_DEL;
const int GroupModifyType_ARRAYSIZE = GroupModifyType_MAX + 1;

enum FileType {
  FILE_TYPE_ONLINE = 1,
  FILE_TYPE_OFFLINE = 2
};
bool FileType_IsValid(int value);
const FileType FileType_MIN = FILE_TYPE_ONLINE;
const FileType FileType_MAX = FILE_TYPE_OFFLINE;
const int FileType_ARRAYSIZE = FileType_MAX + 1;

enum ClientFileState {
  CLIENT_FILE_PEER_READY = 0,
  CLIENT_FILE_CANCEL = 1,
  CLIENT_FILE_REFUSE = 2,
  CLIENT_FILE_DONE = 3
};
bool ClientFileState_IsValid(int value);
const ClientFileState ClientFileState_MIN = CLIENT_FILE_PEER_READY;
const ClientFileState ClientFileState_MAX = CLIENT_FILE_DONE;
const int ClientFileState_ARRAYSIZE = ClientFileState_MAX + 1;

enum ClientFileRole {
  CLIENT_REALTIME_SENDER = 1,
  CLIENT_REALTIME_RECVER = 2,
  CLIENT_OFFLINE_UPLOAD = 3,
  CLIENT_OFFLINE_DOWNLOAD = 4
};
bool ClientFileRole_IsValid(int value);
const ClientFileRole ClientFileRole_MIN = CLIENT_REALTIME_SENDER;
const ClientFileRole ClientFileRole_MAX = CLIENT_OFFLINE_DOWNLOAD;
const int ClientFileRole_ARRAYSIZE = ClientFileRole_MAX + 1;

enum FileServerError {
  FILE_SERVER_ERRNO_OK = 0,
  FILE_SERVER_ERRNO_CREATE_TASK_ID_ERROR = 1,
  FILE_SERVER_ERRNO_CREATE_TASK_ERROR = 2,
  FILE_SERVER_ERRNO_LOGIN_INVALID_TOKEN = 3,
  FILE_SERVER_ERRNO_INVALID_USER_FOR_TASK = 4,
  FILE_SERVER_ERRNO_PULL_DATA_WITH_INVALID_TASK_ID = 5,
  FILE_SERVER_ERRNO_PULL_DATA_ILLIEAGE_USER = 6,
  FILE_SERVER_ERRNO_PULL_DATA_MKDIR_ERROR = 7,
  FILE_SERVER_ERRNO_PULL_DATA_OPEN_FILE_ERROR = 8,
  FILE_SERVER_ERRNO_PULL_DATA_READ_FILE_HEADER_ERROR = 9,
  FILE_SERVER_ERRNO_PULL_DATA_ALLOC_MEM_ERROR = 10,
  FILE_SERVER_ERRNO_PULL_DATA_SEEK_OFFSET_ERROR = 11,
  FILE_SERVER_ERRNO_PULL_DATA_FINISHED = 12
};
bool FileServerError_IsValid(int value);
const FileServerError FileServerError_MIN = FILE_SERVER_ERRNO_OK;
const FileServerError FileServerError_MAX = FILE_SERVER_ERRNO_PULL_DATA_FINISHED;
const int FileServerError_ARRAYSIZE = FileServerError_MAX + 1;

enum SessionStatusType {
  SESSION_STATUS_OK = 0,
  SESSION_STATUS_DELETE = 1
};
bool SessionStatusType_IsValid(int value);
const SessionStatusType SessionStatusType_MIN = SESSION_STATUS_OK;
const SessionStatusType SessionStatusType_MAX = SESSION_STATUS_DELETE;
const int SessionStatusType_ARRAYSIZE = SessionStatusType_MAX + 1;

enum DepartmentStatusType {
  DEPT_STATUS_OK = 0,
  DEPT_STATUS_DELETE = 1
};
bool DepartmentStatusType_IsValid(int value);
const DepartmentStatusType DepartmentStatusType_MIN = DEPT_STATUS_OK;
const DepartmentStatusType DepartmentStatusType_MAX = DEPT_STATUS_DELETE;
const int DepartmentStatusType_ARRAYSIZE = DepartmentStatusType_MAX + 1;

enum FriendResStatusType {
  FRIENDRES_STATUS_AGREE = 0,
  FRIENDRES_STATUS_REFUSE = 1,
  FRIENDRES_STATUS_IGNORE = 2
};
bool FriendResStatusType_IsValid(int value);
const FriendResStatusType FriendResStatusType_MIN = FRIENDRES_STATUS_AGREE;
const FriendResStatusType FriendResStatusType_MAX = FRIENDRES_STATUS_IGNORE;
const int FriendResStatusType_ARRAYSIZE = FriendResStatusType_MAX + 1;

// ===================================================================

class IpAddr : public ::google::protobuf::MessageLite {
 public:
  IpAddr();
  virtual ~IpAddr();

  IpAddr(const IpAddr& from);

  inline IpAddr& operator=(const IpAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IpAddr& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IpAddr* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IpAddr* other);

  // implements Message ----------------------------------------------

  IpAddr* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IpAddr& from);
  void MergeFrom(const IpAddr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 1;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required uint32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.IpAddr)
 private:
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_port();
  inline void clear_has_port();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ip_;
  ::google::protobuf::uint32 port_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static IpAddr* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::MessageLite {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required string user_nickname = 2;
  inline bool has_user_nickname() const;
  inline void clear_user_nickname();
  static const int kUserNicknameFieldNumber = 2;
  inline const ::std::string& user_nickname() const;
  inline void set_user_nickname(const ::std::string& value);
  inline void set_user_nickname(const char* value);
  inline void set_user_nickname(const char* value, size_t size);
  inline ::std::string* mutable_user_nickname();
  inline ::std::string* release_user_nickname();
  inline void set_allocated_user_nickname(::std::string* user_nickname);

  // required uint32 user_gender = 3;
  inline bool has_user_gender() const;
  inline void clear_user_gender();
  static const int kUserGenderFieldNumber = 3;
  inline ::google::protobuf::uint32 user_gender() const;
  inline void set_user_gender(::google::protobuf::uint32 value);

  // required string user_birthday = 4;
  inline bool has_user_birthday() const;
  inline void clear_user_birthday();
  static const int kUserBirthdayFieldNumber = 4;
  inline const ::std::string& user_birthday() const;
  inline void set_user_birthday(const ::std::string& value);
  inline void set_user_birthday(const char* value);
  inline void set_user_birthday(const char* value, size_t size);
  inline ::std::string* mutable_user_birthday();
  inline ::std::string* release_user_birthday();
  inline void set_allocated_user_birthday(::std::string* user_birthday);

  // required string user_headlink = 5;
  inline bool has_user_headlink() const;
  inline void clear_user_headlink();
  static const int kUserHeadlinkFieldNumber = 5;
  inline const ::std::string& user_headlink() const;
  inline void set_user_headlink(const ::std::string& value);
  inline void set_user_headlink(const char* value);
  inline void set_user_headlink(const char* value, size_t size);
  inline ::std::string* mutable_user_headlink();
  inline ::std::string* release_user_headlink();
  inline void set_allocated_user_headlink(::std::string* user_headlink);

  // required uint32 user_level = 6;
  inline bool has_user_level() const;
  inline void clear_user_level();
  static const int kUserLevelFieldNumber = 6;
  inline ::google::protobuf::uint32 user_level() const;
  inline void set_user_level(::google::protobuf::uint32 value);

  // required uint32 user_status = 7;
  inline bool has_user_status() const;
  inline void clear_user_status();
  static const int kUserStatusFieldNumber = 7;
  inline ::google::protobuf::uint32 user_status() const;
  inline void set_user_status(::google::protobuf::uint32 value);

  // optional uint32 user_uid = 8;
  inline bool has_user_uid() const;
  inline void clear_user_uid();
  static const int kUserUidFieldNumber = 8;
  inline ::google::protobuf::uint32 user_uid() const;
  inline void set_user_uid(::google::protobuf::uint32 value);

  // optional string user_phone = 9;
  inline bool has_user_phone() const;
  inline void clear_user_phone();
  static const int kUserPhoneFieldNumber = 9;
  inline const ::std::string& user_phone() const;
  inline void set_user_phone(const ::std::string& value);
  inline void set_user_phone(const char* value);
  inline void set_user_phone(const char* value, size_t size);
  inline ::std::string* mutable_user_phone();
  inline ::std::string* release_user_phone();
  inline void set_allocated_user_phone(::std::string* user_phone);

  // optional uint32 friend_groupid = 10;
  inline bool has_friend_groupid() const;
  inline void clear_friend_groupid();
  static const int kFriendGroupidFieldNumber = 10;
  inline ::google::protobuf::uint32 friend_groupid() const;
  inline void set_friend_groupid(::google::protobuf::uint32 value);

  // optional string friend_remark = 11;
  inline bool has_friend_remark() const;
  inline void clear_friend_remark();
  static const int kFriendRemarkFieldNumber = 11;
  inline const ::std::string& friend_remark() const;
  inline void set_friend_remark(const ::std::string& value);
  inline void set_friend_remark(const char* value);
  inline void set_friend_remark(const char* value, size_t size);
  inline ::std::string* mutable_friend_remark();
  inline ::std::string* release_friend_remark();
  inline void set_allocated_friend_remark(::std::string* friend_remark);

  // optional uint32 friend_status = 12;
  inline bool has_friend_status() const;
  inline void clear_friend_status();
  static const int kFriendStatusFieldNumber = 12;
  inline ::google::protobuf::uint32 friend_status() const;
  inline void set_friend_status(::google::protobuf::uint32 value);

  // optional uint32 user_type = 13;
  inline bool has_user_type() const;
  inline void clear_user_type();
  static const int kUserTypeFieldNumber = 13;
  inline ::google::protobuf::uint32 user_type() const;
  inline void set_user_type(::google::protobuf::uint32 value);

  // optional uint32 user_ischeck = 14;
  inline bool has_user_ischeck() const;
  inline void clear_user_ischeck();
  static const int kUserIscheckFieldNumber = 14;
  inline ::google::protobuf::uint32 user_ischeck() const;
  inline void set_user_ischeck(::google::protobuf::uint32 value);

  // optional string user_desc = 15;
  inline bool has_user_desc() const;
  inline void clear_user_desc();
  static const int kUserDescFieldNumber = 15;
  inline const ::std::string& user_desc() const;
  inline void set_user_desc(const ::std::string& value);
  inline void set_user_desc(const char* value);
  inline void set_user_desc(const char* value, size_t size);
  inline ::std::string* mutable_user_desc();
  inline ::std::string* release_user_desc();
  inline void set_allocated_user_desc(::std::string* user_desc);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UserInfo)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_nickname();
  inline void clear_has_user_nickname();
  inline void set_has_user_gender();
  inline void clear_has_user_gender();
  inline void set_has_user_birthday();
  inline void clear_has_user_birthday();
  inline void set_has_user_headlink();
  inline void clear_has_user_headlink();
  inline void set_has_user_level();
  inline void clear_has_user_level();
  inline void set_has_user_status();
  inline void clear_has_user_status();
  inline void set_has_user_uid();
  inline void clear_has_user_uid();
  inline void set_has_user_phone();
  inline void clear_has_user_phone();
  inline void set_has_friend_groupid();
  inline void clear_has_friend_groupid();
  inline void set_has_friend_remark();
  inline void clear_has_friend_remark();
  inline void set_has_friend_status();
  inline void clear_has_friend_status();
  inline void set_has_user_type();
  inline void clear_has_user_type();
  inline void set_has_user_ischeck();
  inline void clear_has_user_ischeck();
  inline void set_has_user_desc();
  inline void clear_has_user_desc();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_nickname_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 user_gender_;
  ::std::string* user_birthday_;
  ::std::string* user_headlink_;
  ::google::protobuf::uint32 user_level_;
  ::google::protobuf::uint32 user_status_;
  ::std::string* user_phone_;
  ::google::protobuf::uint32 user_uid_;
  ::google::protobuf::uint32 friend_groupid_;
  ::std::string* friend_remark_;
  ::google::protobuf::uint32 friend_status_;
  ::google::protobuf::uint32 user_type_;
  ::std::string* user_desc_;
  ::google::protobuf::uint32 user_ischeck_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContactSessionInfo : public ::google::protobuf::MessageLite {
 public:
  ContactSessionInfo();
  virtual ~ContactSessionInfo();

  ContactSessionInfo(const ContactSessionInfo& from);

  inline ContactSessionInfo& operator=(const ContactSessionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ContactSessionInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ContactSessionInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ContactSessionInfo* other);

  // implements Message ----------------------------------------------

  ContactSessionInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ContactSessionInfo& from);
  void MergeFrom(const ContactSessionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required .IM.BaseDefine.SessionStatusType session_status = 3;
  inline bool has_session_status() const;
  inline void clear_session_status();
  static const int kSessionStatusFieldNumber = 3;
  inline ::IM::BaseDefine::SessionStatusType session_status() const;
  inline void set_session_status(::IM::BaseDefine::SessionStatusType value);

  // required uint32 updated_time = 4;
  inline bool has_updated_time() const;
  inline void clear_updated_time();
  static const int kUpdatedTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 updated_time() const;
  inline void set_updated_time(::google::protobuf::uint32 value);

  // required uint32 latest_msg_id = 5;
  inline bool has_latest_msg_id() const;
  inline void clear_latest_msg_id();
  static const int kLatestMsgIdFieldNumber = 5;
  inline ::google::protobuf::uint32 latest_msg_id() const;
  inline void set_latest_msg_id(::google::protobuf::uint32 value);

  // required bytes latest_msg_data = 6;
  inline bool has_latest_msg_data() const;
  inline void clear_latest_msg_data();
  static const int kLatestMsgDataFieldNumber = 6;
  inline const ::std::string& latest_msg_data() const;
  inline void set_latest_msg_data(const ::std::string& value);
  inline void set_latest_msg_data(const char* value);
  inline void set_latest_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_latest_msg_data();
  inline ::std::string* release_latest_msg_data();
  inline void set_allocated_latest_msg_data(::std::string* latest_msg_data);

  // required .IM.BaseDefine.MsgType latest_msg_type = 7;
  inline bool has_latest_msg_type() const;
  inline void clear_latest_msg_type();
  static const int kLatestMsgTypeFieldNumber = 7;
  inline ::IM::BaseDefine::MsgType latest_msg_type() const;
  inline void set_latest_msg_type(::IM::BaseDefine::MsgType value);

  // required uint32 latest_msg_from_user_id = 8;
  inline bool has_latest_msg_from_user_id() const;
  inline void clear_latest_msg_from_user_id();
  static const int kLatestMsgFromUserIdFieldNumber = 8;
  inline ::google::protobuf::uint32 latest_msg_from_user_id() const;
  inline void set_latest_msg_from_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.ContactSessionInfo)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_session_status();
  inline void clear_has_session_status();
  inline void set_has_updated_time();
  inline void clear_has_updated_time();
  inline void set_has_latest_msg_id();
  inline void clear_has_latest_msg_id();
  inline void set_has_latest_msg_data();
  inline void clear_has_latest_msg_data();
  inline void set_has_latest_msg_type();
  inline void clear_has_latest_msg_type();
  inline void set_has_latest_msg_from_user_id();
  inline void clear_has_latest_msg_from_user_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 session_id_;
  int session_type_;
  int session_status_;
  ::google::protobuf::uint32 updated_time_;
  ::std::string* latest_msg_data_;
  ::google::protobuf::uint32 latest_msg_id_;
  int latest_msg_type_;
  ::google::protobuf::uint32 latest_msg_from_user_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static ContactSessionInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserStat : public ::google::protobuf::MessageLite {
 public:
  UserStat();
  virtual ~UserStat();

  UserStat(const UserStat& from);

  inline UserStat& operator=(const UserStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserStat& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserStat* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserStat* other);

  // implements Message ----------------------------------------------

  UserStat* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserStat& from);
  void MergeFrom(const UserStat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.UserStatType status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::IM::BaseDefine::UserStatType status() const;
  inline void set_status(::IM::BaseDefine::UserStatType value);

  // optional .IM.BaseDefine.ClientType client_type = 3;
  inline bool has_client_type() const;
  inline void clear_client_type();
  static const int kClientTypeFieldNumber = 3;
  inline ::IM::BaseDefine::ClientType client_type() const;
  inline void set_client_type(::IM::BaseDefine::ClientType value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UserStat)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_client_type();
  inline void clear_has_client_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int status_;
  int client_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static UserStat* default_instance_;
};
// -------------------------------------------------------------------

class UnreadInfo : public ::google::protobuf::MessageLite {
 public:
  UnreadInfo();
  virtual ~UnreadInfo();

  UnreadInfo(const UnreadInfo& from);

  inline UnreadInfo& operator=(const UnreadInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UnreadInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnreadInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnreadInfo* other);

  // implements Message ----------------------------------------------

  UnreadInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnreadInfo& from);
  void MergeFrom(const UnreadInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 session_id = 1;
  inline bool has_session_id() const;
  inline void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 session_id() const;
  inline void set_session_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.SessionType session_type = 2;
  inline bool has_session_type() const;
  inline void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  inline ::IM::BaseDefine::SessionType session_type() const;
  inline void set_session_type(::IM::BaseDefine::SessionType value);

  // required uint32 unread_cnt = 3;
  inline bool has_unread_cnt() const;
  inline void clear_unread_cnt();
  static const int kUnreadCntFieldNumber = 3;
  inline ::google::protobuf::uint32 unread_cnt() const;
  inline void set_unread_cnt(::google::protobuf::uint32 value);

  // required uint32 latest_msg_id = 4;
  inline bool has_latest_msg_id() const;
  inline void clear_latest_msg_id();
  static const int kLatestMsgIdFieldNumber = 4;
  inline ::google::protobuf::uint32 latest_msg_id() const;
  inline void set_latest_msg_id(::google::protobuf::uint32 value);

  // required bytes latest_msg_data = 5;
  inline bool has_latest_msg_data() const;
  inline void clear_latest_msg_data();
  static const int kLatestMsgDataFieldNumber = 5;
  inline const ::std::string& latest_msg_data() const;
  inline void set_latest_msg_data(const ::std::string& value);
  inline void set_latest_msg_data(const char* value);
  inline void set_latest_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_latest_msg_data();
  inline ::std::string* release_latest_msg_data();
  inline void set_allocated_latest_msg_data(::std::string* latest_msg_data);

  // required .IM.BaseDefine.MsgType latest_msg_type = 6;
  inline bool has_latest_msg_type() const;
  inline void clear_latest_msg_type();
  static const int kLatestMsgTypeFieldNumber = 6;
  inline ::IM::BaseDefine::MsgType latest_msg_type() const;
  inline void set_latest_msg_type(::IM::BaseDefine::MsgType value);

  // required uint32 latest_msg_from_user_id = 7;
  inline bool has_latest_msg_from_user_id() const;
  inline void clear_latest_msg_from_user_id();
  static const int kLatestMsgFromUserIdFieldNumber = 7;
  inline ::google::protobuf::uint32 latest_msg_from_user_id() const;
  inline void set_latest_msg_from_user_id(::google::protobuf::uint32 value);

  // optional uint32 latest_msg_time = 10;
  inline bool has_latest_msg_time() const;
  inline void clear_latest_msg_time();
  static const int kLatestMsgTimeFieldNumber = 10;
  inline ::google::protobuf::uint32 latest_msg_time() const;
  inline void set_latest_msg_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UnreadInfo)
 private:
  inline void set_has_session_id();
  inline void clear_has_session_id();
  inline void set_has_session_type();
  inline void clear_has_session_type();
  inline void set_has_unread_cnt();
  inline void clear_has_unread_cnt();
  inline void set_has_latest_msg_id();
  inline void clear_has_latest_msg_id();
  inline void set_has_latest_msg_data();
  inline void clear_has_latest_msg_data();
  inline void set_has_latest_msg_type();
  inline void clear_has_latest_msg_type();
  inline void set_has_latest_msg_from_user_id();
  inline void clear_has_latest_msg_from_user_id();
  inline void set_has_latest_msg_time();
  inline void clear_has_latest_msg_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 session_id_;
  int session_type_;
  ::google::protobuf::uint32 unread_cnt_;
  ::google::protobuf::uint32 latest_msg_id_;
  ::std::string* latest_msg_data_;
  int latest_msg_type_;
  ::google::protobuf::uint32 latest_msg_from_user_id_;
  ::google::protobuf::uint32 latest_msg_time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static UnreadInfo* default_instance_;
};
// -------------------------------------------------------------------

class MsgInfo : public ::google::protobuf::MessageLite {
 public:
  MsgInfo();
  virtual ~MsgInfo();

  MsgInfo(const MsgInfo& from);

  inline MsgInfo& operator=(const MsgInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MsgInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MsgInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MsgInfo* other);

  // implements Message ----------------------------------------------

  MsgInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MsgInfo& from);
  void MergeFrom(const MsgInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 msg_id = 1;
  inline bool has_msg_id() const;
  inline void clear_msg_id();
  static const int kMsgIdFieldNumber = 1;
  inline ::google::protobuf::uint32 msg_id() const;
  inline void set_msg_id(::google::protobuf::uint32 value);

  // required uint32 from_session_id = 2;
  inline bool has_from_session_id() const;
  inline void clear_from_session_id();
  static const int kFromSessionIdFieldNumber = 2;
  inline ::google::protobuf::uint32 from_session_id() const;
  inline void set_from_session_id(::google::protobuf::uint32 value);

  // required uint32 create_time = 3;
  inline bool has_create_time() const;
  inline void clear_create_time();
  static const int kCreateTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 create_time() const;
  inline void set_create_time(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.MsgType msg_type = 4;
  inline bool has_msg_type() const;
  inline void clear_msg_type();
  static const int kMsgTypeFieldNumber = 4;
  inline ::IM::BaseDefine::MsgType msg_type() const;
  inline void set_msg_type(::IM::BaseDefine::MsgType value);

  // required bytes msg_data = 5;
  inline bool has_msg_data() const;
  inline void clear_msg_data();
  static const int kMsgDataFieldNumber = 5;
  inline const ::std::string& msg_data() const;
  inline void set_msg_data(const ::std::string& value);
  inline void set_msg_data(const char* value);
  inline void set_msg_data(const void* value, size_t size);
  inline ::std::string* mutable_msg_data();
  inline ::std::string* release_msg_data();
  inline void set_allocated_msg_data(::std::string* msg_data);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.MsgInfo)
 private:
  inline void set_has_msg_id();
  inline void clear_has_msg_id();
  inline void set_has_from_session_id();
  inline void clear_has_from_session_id();
  inline void set_has_create_time();
  inline void clear_has_create_time();
  inline void set_has_msg_type();
  inline void clear_has_msg_type();
  inline void set_has_msg_data();
  inline void clear_has_msg_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 msg_id_;
  ::google::protobuf::uint32 from_session_id_;
  ::google::protobuf::uint32 create_time_;
  int msg_type_;
  ::std::string* msg_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static MsgInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupVersionInfo : public ::google::protobuf::MessageLite {
 public:
  GroupVersionInfo();
  virtual ~GroupVersionInfo();

  GroupVersionInfo(const GroupVersionInfo& from);

  inline GroupVersionInfo& operator=(const GroupVersionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupVersionInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupVersionInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupVersionInfo* other);

  // implements Message ----------------------------------------------

  GroupVersionInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupVersionInfo& from);
  void MergeFrom(const GroupVersionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.GroupVersionInfo)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_version();
  inline void clear_has_version();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 version_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static GroupVersionInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupInfo : public ::google::protobuf::MessageLite {
 public:
  GroupInfo();
  virtual ~GroupInfo();

  GroupInfo(const GroupInfo& from);

  inline GroupInfo& operator=(const GroupInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GroupInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GroupInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GroupInfo* other);

  // implements Message ----------------------------------------------

  GroupInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GroupInfo& from);
  void MergeFrom(const GroupInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required string group_name = 3;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 3;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // required string group_avatar = 4;
  inline bool has_group_avatar() const;
  inline void clear_group_avatar();
  static const int kGroupAvatarFieldNumber = 4;
  inline const ::std::string& group_avatar() const;
  inline void set_group_avatar(const ::std::string& value);
  inline void set_group_avatar(const char* value);
  inline void set_group_avatar(const char* value, size_t size);
  inline ::std::string* mutable_group_avatar();
  inline ::std::string* release_group_avatar();
  inline void set_allocated_group_avatar(::std::string* group_avatar);

  // required uint32 group_creator_id = 5;
  inline bool has_group_creator_id() const;
  inline void clear_group_creator_id();
  static const int kGroupCreatorIdFieldNumber = 5;
  inline ::google::protobuf::uint32 group_creator_id() const;
  inline void set_group_creator_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.GroupType group_type = 6;
  inline bool has_group_type() const;
  inline void clear_group_type();
  static const int kGroupTypeFieldNumber = 6;
  inline ::IM::BaseDefine::GroupType group_type() const;
  inline void set_group_type(::IM::BaseDefine::GroupType value);

  // required uint32 shield_status = 7;
  inline bool has_shield_status() const;
  inline void clear_shield_status();
  static const int kShieldStatusFieldNumber = 7;
  inline ::google::protobuf::uint32 shield_status() const;
  inline void set_shield_status(::google::protobuf::uint32 value);

  // repeated uint32 group_member_list = 8;
  inline int group_member_list_size() const;
  inline void clear_group_member_list();
  static const int kGroupMemberListFieldNumber = 8;
  inline ::google::protobuf::uint32 group_member_list(int index) const;
  inline void set_group_member_list(int index, ::google::protobuf::uint32 value);
  inline void add_group_member_list(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      group_member_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_group_member_list();

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.GroupInfo)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_group_avatar();
  inline void clear_has_group_avatar();
  inline void set_has_group_creator_id();
  inline void clear_has_group_creator_id();
  inline void set_has_group_type();
  inline void clear_has_group_type();
  inline void set_has_shield_status();
  inline void clear_has_shield_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 version_;
  ::std::string* group_name_;
  ::std::string* group_avatar_;
  ::google::protobuf::uint32 group_creator_id_;
  int group_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > group_member_list_;
  ::google::protobuf::uint32 shield_status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static GroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserTokenInfo : public ::google::protobuf::MessageLite {
 public:
  UserTokenInfo();
  virtual ~UserTokenInfo();

  UserTokenInfo(const UserTokenInfo& from);

  inline UserTokenInfo& operator=(const UserTokenInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserTokenInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserTokenInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserTokenInfo* other);

  // implements Message ----------------------------------------------

  UserTokenInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserTokenInfo& from);
  void MergeFrom(const UserTokenInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.ClientType user_type = 2;
  inline bool has_user_type() const;
  inline void clear_user_type();
  static const int kUserTypeFieldNumber = 2;
  inline ::IM::BaseDefine::ClientType user_type() const;
  inline void set_user_type(::IM::BaseDefine::ClientType value);

  // required string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required uint32 push_count = 4;
  inline bool has_push_count() const;
  inline void clear_push_count();
  static const int kPushCountFieldNumber = 4;
  inline ::google::protobuf::uint32 push_count() const;
  inline void set_push_count(::google::protobuf::uint32 value);

  // required uint32 push_type = 5;
  inline bool has_push_type() const;
  inline void clear_push_type();
  static const int kPushTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 push_type() const;
  inline void set_push_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.UserTokenInfo)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_type();
  inline void clear_has_user_type();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_push_count();
  inline void clear_has_push_count();
  inline void set_has_push_type();
  inline void clear_has_push_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  int user_type_;
  ::std::string* token_;
  ::google::protobuf::uint32 push_count_;
  ::google::protobuf::uint32 push_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static UserTokenInfo* default_instance_;
};
// -------------------------------------------------------------------

class PushResult : public ::google::protobuf::MessageLite {
 public:
  PushResult();
  virtual ~PushResult();

  PushResult(const PushResult& from);

  inline PushResult& operator=(const PushResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PushResult& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PushResult* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PushResult* other);

  // implements Message ----------------------------------------------

  PushResult* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PushResult& from);
  void MergeFrom(const PushResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user_token = 1;
  inline bool has_user_token() const;
  inline void clear_user_token();
  static const int kUserTokenFieldNumber = 1;
  inline const ::std::string& user_token() const;
  inline void set_user_token(const ::std::string& value);
  inline void set_user_token(const char* value);
  inline void set_user_token(const char* value, size_t size);
  inline ::std::string* mutable_user_token();
  inline ::std::string* release_user_token();
  inline void set_allocated_user_token(::std::string* user_token);

  // required uint32 result_code = 2;
  inline bool has_result_code() const;
  inline void clear_result_code();
  static const int kResultCodeFieldNumber = 2;
  inline ::google::protobuf::uint32 result_code() const;
  inline void set_result_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.PushResult)
 private:
  inline void set_has_user_token();
  inline void clear_has_user_token();
  inline void set_has_result_code();
  inline void clear_has_result_code();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_token_;
  ::google::protobuf::uint32 result_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static PushResult* default_instance_;
};
// -------------------------------------------------------------------

class ShieldStatus : public ::google::protobuf::MessageLite {
 public:
  ShieldStatus();
  virtual ~ShieldStatus();

  ShieldStatus(const ShieldStatus& from);

  inline ShieldStatus& operator=(const ShieldStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ShieldStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ShieldStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ShieldStatus* other);

  // implements Message ----------------------------------------------

  ShieldStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ShieldStatus& from);
  void MergeFrom(const ShieldStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 user_id() const;
  inline void set_user_id(::google::protobuf::uint32 value);

  // required uint32 group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 shield_status = 3;
  inline bool has_shield_status() const;
  inline void clear_shield_status();
  static const int kShieldStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 shield_status() const;
  inline void set_shield_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.ShieldStatus)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_shield_status();
  inline void clear_has_shield_status();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 shield_status_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static ShieldStatus* default_instance_;
};
// -------------------------------------------------------------------

class OfflineFileInfo : public ::google::protobuf::MessageLite {
 public:
  OfflineFileInfo();
  virtual ~OfflineFileInfo();

  OfflineFileInfo(const OfflineFileInfo& from);

  inline OfflineFileInfo& operator=(const OfflineFileInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const OfflineFileInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OfflineFileInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OfflineFileInfo* other);

  // implements Message ----------------------------------------------

  OfflineFileInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OfflineFileInfo& from);
  void MergeFrom(const OfflineFileInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 from_user_id = 1;
  inline bool has_from_user_id() const;
  inline void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  inline ::google::protobuf::uint32 from_user_id() const;
  inline void set_from_user_id(::google::protobuf::uint32 value);

  // required string task_id = 2;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  inline const ::std::string& task_id() const;
  inline void set_task_id(const ::std::string& value);
  inline void set_task_id(const char* value);
  inline void set_task_id(const char* value, size_t size);
  inline ::std::string* mutable_task_id();
  inline ::std::string* release_task_id();
  inline void set_allocated_task_id(::std::string* task_id);

  // required string file_name = 3;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // required uint32 file_size = 4;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 file_size() const;
  inline void set_file_size(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 10;
  inline int ip_addr_list_size() const;
  inline void clear_ip_addr_list();
  static const int kIpAddrListFieldNumber = 10;
  inline const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  inline ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  inline ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();

  // optional uint32 send_time = 11;
  inline bool has_send_time() const;
  inline void clear_send_time();
  static const int kSendTimeFieldNumber = 11;
  inline ::google::protobuf::uint32 send_time() const;
  inline void set_send_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.OfflineFileInfo)
 private:
  inline void set_has_from_user_id();
  inline void clear_has_from_user_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_send_time();
  inline void clear_has_send_time();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* task_id_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 file_size_;
  ::std::string* file_name_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  ::google::protobuf::uint32 send_time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static OfflineFileInfo* default_instance_;
};
// -------------------------------------------------------------------

class DepartInfo : public ::google::protobuf::MessageLite {
 public:
  DepartInfo();
  virtual ~DepartInfo();

  DepartInfo(const DepartInfo& from);

  inline DepartInfo& operator=(const DepartInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DepartInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DepartInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DepartInfo* other);

  // implements Message ----------------------------------------------

  DepartInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DepartInfo& from);
  void MergeFrom(const DepartInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 group_id = 1;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 1;
  inline ::google::protobuf::uint32 group_id() const;
  inline void set_group_id(::google::protobuf::uint32 value);

  // required uint32 group_flag = 2;
  inline bool has_group_flag() const;
  inline void clear_group_flag();
  static const int kGroupFlagFieldNumber = 2;
  inline ::google::protobuf::uint32 group_flag() const;
  inline void set_group_flag(::google::protobuf::uint32 value);

  // required string group_name = 3;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 3;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // required uint32 group_sort = 4;
  inline bool has_group_sort() const;
  inline void clear_group_sort();
  static const int kGroupSortFieldNumber = 4;
  inline ::google::protobuf::uint32 group_sort() const;
  inline void set_group_sort(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.BaseDefine.DepartInfo)
 private:
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_group_flag();
  inline void clear_has_group_flag();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_group_sort();
  inline void clear_has_group_sort();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 group_id_;
  ::google::protobuf::uint32 group_flag_;
  ::std::string* group_name_;
  ::google::protobuf::uint32 group_sort_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eBaseDefine_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eBaseDefine_2eproto();
  friend void protobuf_ShutdownFile_IM_2eBaseDefine_2eproto();

  void InitAsDefaultInstance();
  static DepartInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// IpAddr

// required string ip = 1;
inline bool IpAddr::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpAddr::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpAddr::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpAddr::clear_ip() {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& IpAddr::ip() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IpAddr.ip)
  return *ip_;
}
inline void IpAddr::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IpAddr.ip)
}
inline void IpAddr::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.IpAddr.ip)
}
inline void IpAddr::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.IpAddr.ip)
}
inline ::std::string* IpAddr::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.IpAddr.ip)
  return ip_;
}
inline ::std::string* IpAddr::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IpAddr::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.IpAddr.ip)
}

// required uint32 port = 2;
inline bool IpAddr::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpAddr::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 IpAddr::port() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.IpAddr.port)
  return port_;
}
inline void IpAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.IpAddr.port)
}

// -------------------------------------------------------------------

// UserInfo

// required uint32 user_id = 1;
inline bool UserInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserInfo::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_id)
  return user_id_;
}
inline void UserInfo::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_id)
}

// required string user_nickname = 2;
inline bool UserInfo::has_user_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_user_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_user_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_user_nickname() {
  if (user_nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_->clear();
  }
  clear_has_user_nickname();
}
inline const ::std::string& UserInfo::user_nickname() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_nickname)
  return *user_nickname_;
}
inline void UserInfo::set_user_nickname(const ::std::string& value) {
  set_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_ = new ::std::string;
  }
  user_nickname_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_nickname)
}
inline void UserInfo::set_user_nickname(const char* value) {
  set_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_ = new ::std::string;
  }
  user_nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.user_nickname)
}
inline void UserInfo::set_user_nickname(const char* value, size_t size) {
  set_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_ = new ::std::string;
  }
  user_nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.user_nickname)
}
inline ::std::string* UserInfo::mutable_user_nickname() {
  set_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_nickname)
  return user_nickname_;
}
inline ::std::string* UserInfo::release_user_nickname() {
  clear_has_user_nickname();
  if (user_nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_nickname_;
    user_nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_user_nickname(::std::string* user_nickname) {
  if (user_nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_nickname_;
  }
  if (user_nickname) {
    set_has_user_nickname();
    user_nickname_ = user_nickname;
  } else {
    clear_has_user_nickname();
    user_nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_nickname)
}

// required uint32 user_gender = 3;
inline bool UserInfo::has_user_gender() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_user_gender() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_user_gender() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_user_gender() {
  user_gender_ = 0u;
  clear_has_user_gender();
}
inline ::google::protobuf::uint32 UserInfo::user_gender() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_gender)
  return user_gender_;
}
inline void UserInfo::set_user_gender(::google::protobuf::uint32 value) {
  set_has_user_gender();
  user_gender_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_gender)
}

// required string user_birthday = 4;
inline bool UserInfo::has_user_birthday() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_user_birthday() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_user_birthday() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_user_birthday() {
  if (user_birthday_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_birthday_->clear();
  }
  clear_has_user_birthday();
}
inline const ::std::string& UserInfo::user_birthday() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_birthday)
  return *user_birthday_;
}
inline void UserInfo::set_user_birthday(const ::std::string& value) {
  set_has_user_birthday();
  if (user_birthday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_birthday_ = new ::std::string;
  }
  user_birthday_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_birthday)
}
inline void UserInfo::set_user_birthday(const char* value) {
  set_has_user_birthday();
  if (user_birthday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_birthday_ = new ::std::string;
  }
  user_birthday_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.user_birthday)
}
inline void UserInfo::set_user_birthday(const char* value, size_t size) {
  set_has_user_birthday();
  if (user_birthday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_birthday_ = new ::std::string;
  }
  user_birthday_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.user_birthday)
}
inline ::std::string* UserInfo::mutable_user_birthday() {
  set_has_user_birthday();
  if (user_birthday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_birthday_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_birthday)
  return user_birthday_;
}
inline ::std::string* UserInfo::release_user_birthday() {
  clear_has_user_birthday();
  if (user_birthday_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_birthday_;
    user_birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_user_birthday(::std::string* user_birthday) {
  if (user_birthday_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_birthday_;
  }
  if (user_birthday) {
    set_has_user_birthday();
    user_birthday_ = user_birthday;
  } else {
    clear_has_user_birthday();
    user_birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_birthday)
}

// required string user_headlink = 5;
inline bool UserInfo::has_user_headlink() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_user_headlink() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_user_headlink() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_user_headlink() {
  if (user_headlink_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_headlink_->clear();
  }
  clear_has_user_headlink();
}
inline const ::std::string& UserInfo::user_headlink() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_headlink)
  return *user_headlink_;
}
inline void UserInfo::set_user_headlink(const ::std::string& value) {
  set_has_user_headlink();
  if (user_headlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_headlink_ = new ::std::string;
  }
  user_headlink_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_headlink)
}
inline void UserInfo::set_user_headlink(const char* value) {
  set_has_user_headlink();
  if (user_headlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_headlink_ = new ::std::string;
  }
  user_headlink_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.user_headlink)
}
inline void UserInfo::set_user_headlink(const char* value, size_t size) {
  set_has_user_headlink();
  if (user_headlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_headlink_ = new ::std::string;
  }
  user_headlink_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.user_headlink)
}
inline ::std::string* UserInfo::mutable_user_headlink() {
  set_has_user_headlink();
  if (user_headlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_headlink_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_headlink)
  return user_headlink_;
}
inline ::std::string* UserInfo::release_user_headlink() {
  clear_has_user_headlink();
  if (user_headlink_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_headlink_;
    user_headlink_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_user_headlink(::std::string* user_headlink) {
  if (user_headlink_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_headlink_;
  }
  if (user_headlink) {
    set_has_user_headlink();
    user_headlink_ = user_headlink;
  } else {
    clear_has_user_headlink();
    user_headlink_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_headlink)
}

// required uint32 user_level = 6;
inline bool UserInfo::has_user_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_user_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_user_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_user_level() {
  user_level_ = 0u;
  clear_has_user_level();
}
inline ::google::protobuf::uint32 UserInfo::user_level() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_level)
  return user_level_;
}
inline void UserInfo::set_user_level(::google::protobuf::uint32 value) {
  set_has_user_level();
  user_level_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_level)
}

// required uint32 user_status = 7;
inline bool UserInfo::has_user_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_user_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_user_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_user_status() {
  user_status_ = 0u;
  clear_has_user_status();
}
inline ::google::protobuf::uint32 UserInfo::user_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_status)
  return user_status_;
}
inline void UserInfo::set_user_status(::google::protobuf::uint32 value) {
  set_has_user_status();
  user_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_status)
}

// optional uint32 user_uid = 8;
inline bool UserInfo::has_user_uid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_user_uid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_user_uid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_user_uid() {
  user_uid_ = 0u;
  clear_has_user_uid();
}
inline ::google::protobuf::uint32 UserInfo::user_uid() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_uid)
  return user_uid_;
}
inline void UserInfo::set_user_uid(::google::protobuf::uint32 value) {
  set_has_user_uid();
  user_uid_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_uid)
}

// optional string user_phone = 9;
inline bool UserInfo::has_user_phone() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_user_phone() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_user_phone() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_user_phone() {
  if (user_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_phone_->clear();
  }
  clear_has_user_phone();
}
inline const ::std::string& UserInfo::user_phone() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_phone)
  return *user_phone_;
}
inline void UserInfo::set_user_phone(const ::std::string& value) {
  set_has_user_phone();
  if (user_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_phone_ = new ::std::string;
  }
  user_phone_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_phone)
}
inline void UserInfo::set_user_phone(const char* value) {
  set_has_user_phone();
  if (user_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_phone_ = new ::std::string;
  }
  user_phone_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.user_phone)
}
inline void UserInfo::set_user_phone(const char* value, size_t size) {
  set_has_user_phone();
  if (user_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_phone_ = new ::std::string;
  }
  user_phone_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.user_phone)
}
inline ::std::string* UserInfo::mutable_user_phone() {
  set_has_user_phone();
  if (user_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_phone_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_phone)
  return user_phone_;
}
inline ::std::string* UserInfo::release_user_phone() {
  clear_has_user_phone();
  if (user_phone_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_phone_;
    user_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_user_phone(::std::string* user_phone) {
  if (user_phone_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_phone_;
  }
  if (user_phone) {
    set_has_user_phone();
    user_phone_ = user_phone;
  } else {
    clear_has_user_phone();
    user_phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_phone)
}

// optional uint32 friend_groupid = 10;
inline bool UserInfo::has_friend_groupid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfo::set_has_friend_groupid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfo::clear_has_friend_groupid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfo::clear_friend_groupid() {
  friend_groupid_ = 0u;
  clear_has_friend_groupid();
}
inline ::google::protobuf::uint32 UserInfo::friend_groupid() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.friend_groupid)
  return friend_groupid_;
}
inline void UserInfo::set_friend_groupid(::google::protobuf::uint32 value) {
  set_has_friend_groupid();
  friend_groupid_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.friend_groupid)
}

// optional string friend_remark = 11;
inline bool UserInfo::has_friend_remark() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserInfo::set_has_friend_remark() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserInfo::clear_has_friend_remark() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserInfo::clear_friend_remark() {
  if (friend_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_remark_->clear();
  }
  clear_has_friend_remark();
}
inline const ::std::string& UserInfo::friend_remark() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.friend_remark)
  return *friend_remark_;
}
inline void UserInfo::set_friend_remark(const ::std::string& value) {
  set_has_friend_remark();
  if (friend_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_remark_ = new ::std::string;
  }
  friend_remark_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.friend_remark)
}
inline void UserInfo::set_friend_remark(const char* value) {
  set_has_friend_remark();
  if (friend_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_remark_ = new ::std::string;
  }
  friend_remark_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.friend_remark)
}
inline void UserInfo::set_friend_remark(const char* value, size_t size) {
  set_has_friend_remark();
  if (friend_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_remark_ = new ::std::string;
  }
  friend_remark_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.friend_remark)
}
inline ::std::string* UserInfo::mutable_friend_remark() {
  set_has_friend_remark();
  if (friend_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    friend_remark_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.friend_remark)
  return friend_remark_;
}
inline ::std::string* UserInfo::release_friend_remark() {
  clear_has_friend_remark();
  if (friend_remark_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = friend_remark_;
    friend_remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_friend_remark(::std::string* friend_remark) {
  if (friend_remark_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete friend_remark_;
  }
  if (friend_remark) {
    set_has_friend_remark();
    friend_remark_ = friend_remark;
  } else {
    clear_has_friend_remark();
    friend_remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.friend_remark)
}

// optional uint32 friend_status = 12;
inline bool UserInfo::has_friend_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserInfo::set_has_friend_status() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserInfo::clear_has_friend_status() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserInfo::clear_friend_status() {
  friend_status_ = 0u;
  clear_has_friend_status();
}
inline ::google::protobuf::uint32 UserInfo::friend_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.friend_status)
  return friend_status_;
}
inline void UserInfo::set_friend_status(::google::protobuf::uint32 value) {
  set_has_friend_status();
  friend_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.friend_status)
}

// optional uint32 user_type = 13;
inline bool UserInfo::has_user_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserInfo::set_has_user_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserInfo::clear_has_user_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserInfo::clear_user_type() {
  user_type_ = 0u;
  clear_has_user_type();
}
inline ::google::protobuf::uint32 UserInfo::user_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_type)
  return user_type_;
}
inline void UserInfo::set_user_type(::google::protobuf::uint32 value) {
  set_has_user_type();
  user_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_type)
}

// optional uint32 user_ischeck = 14;
inline bool UserInfo::has_user_ischeck() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserInfo::set_has_user_ischeck() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserInfo::clear_has_user_ischeck() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserInfo::clear_user_ischeck() {
  user_ischeck_ = 0u;
  clear_has_user_ischeck();
}
inline ::google::protobuf::uint32 UserInfo::user_ischeck() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_ischeck)
  return user_ischeck_;
}
inline void UserInfo::set_user_ischeck(::google::protobuf::uint32 value) {
  set_has_user_ischeck();
  user_ischeck_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_ischeck)
}

// optional string user_desc = 15;
inline bool UserInfo::has_user_desc() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserInfo::set_has_user_desc() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserInfo::clear_has_user_desc() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserInfo::clear_user_desc() {
  if (user_desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_desc_->clear();
  }
  clear_has_user_desc();
}
inline const ::std::string& UserInfo::user_desc() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserInfo.user_desc)
  return *user_desc_;
}
inline void UserInfo::set_user_desc(const ::std::string& value) {
  set_has_user_desc();
  if (user_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_desc_ = new ::std::string;
  }
  user_desc_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserInfo.user_desc)
}
inline void UserInfo::set_user_desc(const char* value) {
  set_has_user_desc();
  if (user_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_desc_ = new ::std::string;
  }
  user_desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserInfo.user_desc)
}
inline void UserInfo::set_user_desc(const char* value, size_t size) {
  set_has_user_desc();
  if (user_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_desc_ = new ::std::string;
  }
  user_desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserInfo.user_desc)
}
inline ::std::string* UserInfo::mutable_user_desc() {
  set_has_user_desc();
  if (user_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserInfo.user_desc)
  return user_desc_;
}
inline ::std::string* UserInfo::release_user_desc() {
  clear_has_user_desc();
  if (user_desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_desc_;
    user_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserInfo::set_allocated_user_desc(::std::string* user_desc) {
  if (user_desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_desc_;
  }
  if (user_desc) {
    set_has_user_desc();
    user_desc_ = user_desc;
  } else {
    clear_has_user_desc();
    user_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserInfo.user_desc)
}

// -------------------------------------------------------------------

// ContactSessionInfo

// required uint32 session_id = 1;
inline bool ContactSessionInfo::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactSessionInfo::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactSessionInfo::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactSessionInfo::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 ContactSessionInfo::session_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.session_id)
  return session_id_;
}
inline void ContactSessionInfo::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.session_id)
}

// required .IM.BaseDefine.SessionType session_type = 2;
inline bool ContactSessionInfo::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactSessionInfo::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactSessionInfo::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactSessionInfo::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType ContactSessionInfo::session_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void ContactSessionInfo::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.session_type)
}

// required .IM.BaseDefine.SessionStatusType session_status = 3;
inline bool ContactSessionInfo::has_session_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContactSessionInfo::set_has_session_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContactSessionInfo::clear_has_session_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContactSessionInfo::clear_session_status() {
  session_status_ = 0;
  clear_has_session_status();
}
inline ::IM::BaseDefine::SessionStatusType ContactSessionInfo::session_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.session_status)
  return static_cast< ::IM::BaseDefine::SessionStatusType >(session_status_);
}
inline void ContactSessionInfo::set_session_status(::IM::BaseDefine::SessionStatusType value) {
  assert(::IM::BaseDefine::SessionStatusType_IsValid(value));
  set_has_session_status();
  session_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.session_status)
}

// required uint32 updated_time = 4;
inline bool ContactSessionInfo::has_updated_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContactSessionInfo::set_has_updated_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContactSessionInfo::clear_has_updated_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContactSessionInfo::clear_updated_time() {
  updated_time_ = 0u;
  clear_has_updated_time();
}
inline ::google::protobuf::uint32 ContactSessionInfo::updated_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.updated_time)
  return updated_time_;
}
inline void ContactSessionInfo::set_updated_time(::google::protobuf::uint32 value) {
  set_has_updated_time();
  updated_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.updated_time)
}

// required uint32 latest_msg_id = 5;
inline bool ContactSessionInfo::has_latest_msg_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContactSessionInfo::set_has_latest_msg_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContactSessionInfo::clear_has_latest_msg_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContactSessionInfo::clear_latest_msg_id() {
  latest_msg_id_ = 0u;
  clear_has_latest_msg_id();
}
inline ::google::protobuf::uint32 ContactSessionInfo::latest_msg_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.latest_msg_id)
  return latest_msg_id_;
}
inline void ContactSessionInfo::set_latest_msg_id(::google::protobuf::uint32 value) {
  set_has_latest_msg_id();
  latest_msg_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.latest_msg_id)
}

// required bytes latest_msg_data = 6;
inline bool ContactSessionInfo::has_latest_msg_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContactSessionInfo::set_has_latest_msg_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContactSessionInfo::clear_has_latest_msg_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContactSessionInfo::clear_latest_msg_data() {
  if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_->clear();
  }
  clear_has_latest_msg_data();
}
inline const ::std::string& ContactSessionInfo::latest_msg_data() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
  return *latest_msg_data_;
}
inline void ContactSessionInfo::set_latest_msg_data(const ::std::string& value) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
}
inline void ContactSessionInfo::set_latest_msg_data(const char* value) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
}
inline void ContactSessionInfo::set_latest_msg_data(const void* value, size_t size) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
}
inline ::std::string* ContactSessionInfo::mutable_latest_msg_data() {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
  return latest_msg_data_;
}
inline ::std::string* ContactSessionInfo::release_latest_msg_data() {
  clear_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = latest_msg_data_;
    latest_msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ContactSessionInfo::set_allocated_latest_msg_data(::std::string* latest_msg_data) {
  if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete latest_msg_data_;
  }
  if (latest_msg_data) {
    set_has_latest_msg_data();
    latest_msg_data_ = latest_msg_data;
  } else {
    clear_has_latest_msg_data();
    latest_msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.ContactSessionInfo.latest_msg_data)
}

// required .IM.BaseDefine.MsgType latest_msg_type = 7;
inline bool ContactSessionInfo::has_latest_msg_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContactSessionInfo::set_has_latest_msg_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContactSessionInfo::clear_has_latest_msg_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContactSessionInfo::clear_latest_msg_type() {
  latest_msg_type_ = 1;
  clear_has_latest_msg_type();
}
inline ::IM::BaseDefine::MsgType ContactSessionInfo::latest_msg_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.latest_msg_type)
  return static_cast< ::IM::BaseDefine::MsgType >(latest_msg_type_);
}
inline void ContactSessionInfo::set_latest_msg_type(::IM::BaseDefine::MsgType value) {
  assert(::IM::BaseDefine::MsgType_IsValid(value));
  set_has_latest_msg_type();
  latest_msg_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.latest_msg_type)
}

// required uint32 latest_msg_from_user_id = 8;
inline bool ContactSessionInfo::has_latest_msg_from_user_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ContactSessionInfo::set_has_latest_msg_from_user_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ContactSessionInfo::clear_has_latest_msg_from_user_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ContactSessionInfo::clear_latest_msg_from_user_id() {
  latest_msg_from_user_id_ = 0u;
  clear_has_latest_msg_from_user_id();
}
inline ::google::protobuf::uint32 ContactSessionInfo::latest_msg_from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ContactSessionInfo.latest_msg_from_user_id)
  return latest_msg_from_user_id_;
}
inline void ContactSessionInfo::set_latest_msg_from_user_id(::google::protobuf::uint32 value) {
  set_has_latest_msg_from_user_id();
  latest_msg_from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ContactSessionInfo.latest_msg_from_user_id)
}

// -------------------------------------------------------------------

// UserStat

// required uint32 user_id = 1;
inline bool UserStat::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStat::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStat::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStat::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserStat::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserStat.user_id)
  return user_id_;
}
inline void UserStat::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserStat.user_id)
}

// required .IM.BaseDefine.UserStatType status = 2;
inline bool UserStat::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStat::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStat::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStat::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::IM::BaseDefine::UserStatType UserStat::status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserStat.status)
  return static_cast< ::IM::BaseDefine::UserStatType >(status_);
}
inline void UserStat::set_status(::IM::BaseDefine::UserStatType value) {
  assert(::IM::BaseDefine::UserStatType_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserStat.status)
}

// optional .IM.BaseDefine.ClientType client_type = 3;
inline bool UserStat::has_client_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserStat::set_has_client_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserStat::clear_has_client_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserStat::clear_client_type() {
  client_type_ = 1;
  clear_has_client_type();
}
inline ::IM::BaseDefine::ClientType UserStat::client_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserStat.client_type)
  return static_cast< ::IM::BaseDefine::ClientType >(client_type_);
}
inline void UserStat::set_client_type(::IM::BaseDefine::ClientType value) {
  assert(::IM::BaseDefine::ClientType_IsValid(value));
  set_has_client_type();
  client_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserStat.client_type)
}

// -------------------------------------------------------------------

// UnreadInfo

// required uint32 session_id = 1;
inline bool UnreadInfo::has_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnreadInfo::set_has_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnreadInfo::clear_has_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnreadInfo::clear_session_id() {
  session_id_ = 0u;
  clear_has_session_id();
}
inline ::google::protobuf::uint32 UnreadInfo::session_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.session_id)
  return session_id_;
}
inline void UnreadInfo::set_session_id(::google::protobuf::uint32 value) {
  set_has_session_id();
  session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.session_id)
}

// required .IM.BaseDefine.SessionType session_type = 2;
inline bool UnreadInfo::has_session_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnreadInfo::set_has_session_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnreadInfo::clear_has_session_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnreadInfo::clear_session_type() {
  session_type_ = 1;
  clear_has_session_type();
}
inline ::IM::BaseDefine::SessionType UnreadInfo::session_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.session_type)
  return static_cast< ::IM::BaseDefine::SessionType >(session_type_);
}
inline void UnreadInfo::set_session_type(::IM::BaseDefine::SessionType value) {
  assert(::IM::BaseDefine::SessionType_IsValid(value));
  set_has_session_type();
  session_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.session_type)
}

// required uint32 unread_cnt = 3;
inline bool UnreadInfo::has_unread_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnreadInfo::set_has_unread_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnreadInfo::clear_has_unread_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnreadInfo::clear_unread_cnt() {
  unread_cnt_ = 0u;
  clear_has_unread_cnt();
}
inline ::google::protobuf::uint32 UnreadInfo::unread_cnt() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.unread_cnt)
  return unread_cnt_;
}
inline void UnreadInfo::set_unread_cnt(::google::protobuf::uint32 value) {
  set_has_unread_cnt();
  unread_cnt_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.unread_cnt)
}

// required uint32 latest_msg_id = 4;
inline bool UnreadInfo::has_latest_msg_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UnreadInfo::set_has_latest_msg_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UnreadInfo::clear_has_latest_msg_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UnreadInfo::clear_latest_msg_id() {
  latest_msg_id_ = 0u;
  clear_has_latest_msg_id();
}
inline ::google::protobuf::uint32 UnreadInfo::latest_msg_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.latest_msg_id)
  return latest_msg_id_;
}
inline void UnreadInfo::set_latest_msg_id(::google::protobuf::uint32 value) {
  set_has_latest_msg_id();
  latest_msg_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.latest_msg_id)
}

// required bytes latest_msg_data = 5;
inline bool UnreadInfo::has_latest_msg_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UnreadInfo::set_has_latest_msg_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UnreadInfo::clear_has_latest_msg_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UnreadInfo::clear_latest_msg_data() {
  if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_->clear();
  }
  clear_has_latest_msg_data();
}
inline const ::std::string& UnreadInfo::latest_msg_data() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.latest_msg_data)
  return *latest_msg_data_;
}
inline void UnreadInfo::set_latest_msg_data(const ::std::string& value) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.latest_msg_data)
}
inline void UnreadInfo::set_latest_msg_data(const char* value) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UnreadInfo.latest_msg_data)
}
inline void UnreadInfo::set_latest_msg_data(const void* value, size_t size) {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  latest_msg_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UnreadInfo.latest_msg_data)
}
inline ::std::string* UnreadInfo::mutable_latest_msg_data() {
  set_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    latest_msg_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UnreadInfo.latest_msg_data)
  return latest_msg_data_;
}
inline ::std::string* UnreadInfo::release_latest_msg_data() {
  clear_has_latest_msg_data();
  if (latest_msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = latest_msg_data_;
    latest_msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UnreadInfo::set_allocated_latest_msg_data(::std::string* latest_msg_data) {
  if (latest_msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete latest_msg_data_;
  }
  if (latest_msg_data) {
    set_has_latest_msg_data();
    latest_msg_data_ = latest_msg_data;
  } else {
    clear_has_latest_msg_data();
    latest_msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UnreadInfo.latest_msg_data)
}

// required .IM.BaseDefine.MsgType latest_msg_type = 6;
inline bool UnreadInfo::has_latest_msg_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UnreadInfo::set_has_latest_msg_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UnreadInfo::clear_has_latest_msg_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UnreadInfo::clear_latest_msg_type() {
  latest_msg_type_ = 1;
  clear_has_latest_msg_type();
}
inline ::IM::BaseDefine::MsgType UnreadInfo::latest_msg_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.latest_msg_type)
  return static_cast< ::IM::BaseDefine::MsgType >(latest_msg_type_);
}
inline void UnreadInfo::set_latest_msg_type(::IM::BaseDefine::MsgType value) {
  assert(::IM::BaseDefine::MsgType_IsValid(value));
  set_has_latest_msg_type();
  latest_msg_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.latest_msg_type)
}

// required uint32 latest_msg_from_user_id = 7;
inline bool UnreadInfo::has_latest_msg_from_user_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UnreadInfo::set_has_latest_msg_from_user_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UnreadInfo::clear_has_latest_msg_from_user_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UnreadInfo::clear_latest_msg_from_user_id() {
  latest_msg_from_user_id_ = 0u;
  clear_has_latest_msg_from_user_id();
}
inline ::google::protobuf::uint32 UnreadInfo::latest_msg_from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.latest_msg_from_user_id)
  return latest_msg_from_user_id_;
}
inline void UnreadInfo::set_latest_msg_from_user_id(::google::protobuf::uint32 value) {
  set_has_latest_msg_from_user_id();
  latest_msg_from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.latest_msg_from_user_id)
}

// optional uint32 latest_msg_time = 10;
inline bool UnreadInfo::has_latest_msg_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UnreadInfo::set_has_latest_msg_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UnreadInfo::clear_has_latest_msg_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UnreadInfo::clear_latest_msg_time() {
  latest_msg_time_ = 0u;
  clear_has_latest_msg_time();
}
inline ::google::protobuf::uint32 UnreadInfo::latest_msg_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UnreadInfo.latest_msg_time)
  return latest_msg_time_;
}
inline void UnreadInfo::set_latest_msg_time(::google::protobuf::uint32 value) {
  set_has_latest_msg_time();
  latest_msg_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UnreadInfo.latest_msg_time)
}

// -------------------------------------------------------------------

// MsgInfo

// required uint32 msg_id = 1;
inline bool MsgInfo::has_msg_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgInfo::set_has_msg_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgInfo::clear_has_msg_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgInfo::clear_msg_id() {
  msg_id_ = 0u;
  clear_has_msg_id();
}
inline ::google::protobuf::uint32 MsgInfo::msg_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.msg_id)
  return msg_id_;
}
inline void MsgInfo::set_msg_id(::google::protobuf::uint32 value) {
  set_has_msg_id();
  msg_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.msg_id)
}

// required uint32 from_session_id = 2;
inline bool MsgInfo::has_from_session_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgInfo::set_has_from_session_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgInfo::clear_has_from_session_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgInfo::clear_from_session_id() {
  from_session_id_ = 0u;
  clear_has_from_session_id();
}
inline ::google::protobuf::uint32 MsgInfo::from_session_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.from_session_id)
  return from_session_id_;
}
inline void MsgInfo::set_from_session_id(::google::protobuf::uint32 value) {
  set_has_from_session_id();
  from_session_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.from_session_id)
}

// required uint32 create_time = 3;
inline bool MsgInfo::has_create_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgInfo::set_has_create_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgInfo::clear_has_create_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgInfo::clear_create_time() {
  create_time_ = 0u;
  clear_has_create_time();
}
inline ::google::protobuf::uint32 MsgInfo::create_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.create_time)
  return create_time_;
}
inline void MsgInfo::set_create_time(::google::protobuf::uint32 value) {
  set_has_create_time();
  create_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.create_time)
}

// required .IM.BaseDefine.MsgType msg_type = 4;
inline bool MsgInfo::has_msg_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgInfo::set_has_msg_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgInfo::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgInfo::clear_msg_type() {
  msg_type_ = 1;
  clear_has_msg_type();
}
inline ::IM::BaseDefine::MsgType MsgInfo::msg_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.msg_type)
  return static_cast< ::IM::BaseDefine::MsgType >(msg_type_);
}
inline void MsgInfo::set_msg_type(::IM::BaseDefine::MsgType value) {
  assert(::IM::BaseDefine::MsgType_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.msg_type)
}

// required bytes msg_data = 5;
inline bool MsgInfo::has_msg_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgInfo::set_has_msg_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgInfo::clear_has_msg_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgInfo::clear_msg_data() {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_->clear();
  }
  clear_has_msg_data();
}
inline const ::std::string& MsgInfo::msg_data() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.MsgInfo.msg_data)
  return *msg_data_;
}
inline void MsgInfo::set_msg_data(const ::std::string& value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.MsgInfo.msg_data)
}
inline void MsgInfo::set_msg_data(const char* value) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.MsgInfo.msg_data)
}
inline void MsgInfo::set_msg_data(const void* value, size_t size) {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  msg_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.MsgInfo.msg_data)
}
inline ::std::string* MsgInfo::mutable_msg_data() {
  set_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    msg_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.MsgInfo.msg_data)
  return msg_data_;
}
inline ::std::string* MsgInfo::release_msg_data() {
  clear_has_msg_data();
  if (msg_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = msg_data_;
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void MsgInfo::set_allocated_msg_data(::std::string* msg_data) {
  if (msg_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete msg_data_;
  }
  if (msg_data) {
    set_has_msg_data();
    msg_data_ = msg_data;
  } else {
    clear_has_msg_data();
    msg_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.MsgInfo.msg_data)
}

// -------------------------------------------------------------------

// GroupVersionInfo

// required uint32 group_id = 1;
inline bool GroupVersionInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupVersionInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupVersionInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupVersionInfo::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupVersionInfo::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupVersionInfo.group_id)
  return group_id_;
}
inline void GroupVersionInfo::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupVersionInfo.group_id)
}

// required uint32 version = 2;
inline bool GroupVersionInfo::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupVersionInfo::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupVersionInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupVersionInfo::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 GroupVersionInfo::version() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupVersionInfo.version)
  return version_;
}
inline void GroupVersionInfo::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupVersionInfo.version)
}

// -------------------------------------------------------------------

// GroupInfo

// required uint32 group_id = 1;
inline bool GroupInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupInfo::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 GroupInfo::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_id)
  return group_id_;
}
inline void GroupInfo::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_id)
}

// required uint32 version = 2;
inline bool GroupInfo::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupInfo::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupInfo::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 GroupInfo::version() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.version)
  return version_;
}
inline void GroupInfo::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.version)
}

// required string group_name = 3;
inline bool GroupInfo::has_group_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupInfo::set_has_group_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupInfo::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupInfo::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& GroupInfo::group_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_name)
  return *group_name_;
}
inline void GroupInfo::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_name)
}
inline void GroupInfo::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.GroupInfo.group_name)
}
inline void GroupInfo::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.GroupInfo.group_name)
}
inline ::std::string* GroupInfo::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.GroupInfo.group_name)
  return group_name_;
}
inline ::std::string* GroupInfo::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupInfo::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.GroupInfo.group_name)
}

// required string group_avatar = 4;
inline bool GroupInfo::has_group_avatar() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupInfo::set_has_group_avatar() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupInfo::clear_has_group_avatar() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupInfo::clear_group_avatar() {
  if (group_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_->clear();
  }
  clear_has_group_avatar();
}
inline const ::std::string& GroupInfo::group_avatar() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_avatar)
  return *group_avatar_;
}
inline void GroupInfo::set_group_avatar(const ::std::string& value) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_avatar)
}
inline void GroupInfo::set_group_avatar(const char* value) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.GroupInfo.group_avatar)
}
inline void GroupInfo::set_group_avatar(const char* value, size_t size) {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  group_avatar_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.GroupInfo.group_avatar)
}
inline ::std::string* GroupInfo::mutable_group_avatar() {
  set_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_avatar_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.GroupInfo.group_avatar)
  return group_avatar_;
}
inline ::std::string* GroupInfo::release_group_avatar() {
  clear_has_group_avatar();
  if (group_avatar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_avatar_;
    group_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GroupInfo::set_allocated_group_avatar(::std::string* group_avatar) {
  if (group_avatar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_avatar_;
  }
  if (group_avatar) {
    set_has_group_avatar();
    group_avatar_ = group_avatar;
  } else {
    clear_has_group_avatar();
    group_avatar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.GroupInfo.group_avatar)
}

// required uint32 group_creator_id = 5;
inline bool GroupInfo::has_group_creator_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupInfo::set_has_group_creator_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupInfo::clear_has_group_creator_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupInfo::clear_group_creator_id() {
  group_creator_id_ = 0u;
  clear_has_group_creator_id();
}
inline ::google::protobuf::uint32 GroupInfo::group_creator_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_creator_id)
  return group_creator_id_;
}
inline void GroupInfo::set_group_creator_id(::google::protobuf::uint32 value) {
  set_has_group_creator_id();
  group_creator_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_creator_id)
}

// required .IM.BaseDefine.GroupType group_type = 6;
inline bool GroupInfo::has_group_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupInfo::set_has_group_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupInfo::clear_has_group_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupInfo::clear_group_type() {
  group_type_ = 1;
  clear_has_group_type();
}
inline ::IM::BaseDefine::GroupType GroupInfo::group_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_type)
  return static_cast< ::IM::BaseDefine::GroupType >(group_type_);
}
inline void GroupInfo::set_group_type(::IM::BaseDefine::GroupType value) {
  assert(::IM::BaseDefine::GroupType_IsValid(value));
  set_has_group_type();
  group_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_type)
}

// required uint32 shield_status = 7;
inline bool GroupInfo::has_shield_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupInfo::set_has_shield_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupInfo::clear_has_shield_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupInfo::clear_shield_status() {
  shield_status_ = 0u;
  clear_has_shield_status();
}
inline ::google::protobuf::uint32 GroupInfo::shield_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.shield_status)
  return shield_status_;
}
inline void GroupInfo::set_shield_status(::google::protobuf::uint32 value) {
  set_has_shield_status();
  shield_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.shield_status)
}

// repeated uint32 group_member_list = 8;
inline int GroupInfo::group_member_list_size() const {
  return group_member_list_.size();
}
inline void GroupInfo::clear_group_member_list() {
  group_member_list_.Clear();
}
inline ::google::protobuf::uint32 GroupInfo::group_member_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.GroupInfo.group_member_list)
  return group_member_list_.Get(index);
}
inline void GroupInfo::set_group_member_list(int index, ::google::protobuf::uint32 value) {
  group_member_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.GroupInfo.group_member_list)
}
inline void GroupInfo::add_group_member_list(::google::protobuf::uint32 value) {
  group_member_list_.Add(value);
  // @@protoc_insertion_point(field_add:IM.BaseDefine.GroupInfo.group_member_list)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GroupInfo::group_member_list() const {
  // @@protoc_insertion_point(field_list:IM.BaseDefine.GroupInfo.group_member_list)
  return group_member_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GroupInfo::mutable_group_member_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.BaseDefine.GroupInfo.group_member_list)
  return &group_member_list_;
}

// -------------------------------------------------------------------

// UserTokenInfo

// required uint32 user_id = 1;
inline bool UserTokenInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTokenInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTokenInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTokenInfo::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 UserTokenInfo::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.user_id)
  return user_id_;
}
inline void UserTokenInfo::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.user_id)
}

// required .IM.BaseDefine.ClientType user_type = 2;
inline bool UserTokenInfo::has_user_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTokenInfo::set_has_user_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTokenInfo::clear_has_user_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTokenInfo::clear_user_type() {
  user_type_ = 1;
  clear_has_user_type();
}
inline ::IM::BaseDefine::ClientType UserTokenInfo::user_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.user_type)
  return static_cast< ::IM::BaseDefine::ClientType >(user_type_);
}
inline void UserTokenInfo::set_user_type(::IM::BaseDefine::ClientType value) {
  assert(::IM::BaseDefine::ClientType_IsValid(value));
  set_has_user_type();
  user_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.user_type)
}

// required string token = 3;
inline bool UserTokenInfo::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserTokenInfo::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserTokenInfo::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserTokenInfo::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& UserTokenInfo::token() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.token)
  return *token_;
}
inline void UserTokenInfo::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.token)
}
inline void UserTokenInfo::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.UserTokenInfo.token)
}
inline void UserTokenInfo::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.UserTokenInfo.token)
}
inline ::std::string* UserTokenInfo::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.UserTokenInfo.token)
  return token_;
}
inline ::std::string* UserTokenInfo::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UserTokenInfo::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.UserTokenInfo.token)
}

// required uint32 push_count = 4;
inline bool UserTokenInfo::has_push_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserTokenInfo::set_has_push_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserTokenInfo::clear_has_push_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserTokenInfo::clear_push_count() {
  push_count_ = 0u;
  clear_has_push_count();
}
inline ::google::protobuf::uint32 UserTokenInfo::push_count() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.push_count)
  return push_count_;
}
inline void UserTokenInfo::set_push_count(::google::protobuf::uint32 value) {
  set_has_push_count();
  push_count_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.push_count)
}

// required uint32 push_type = 5;
inline bool UserTokenInfo::has_push_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserTokenInfo::set_has_push_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserTokenInfo::clear_has_push_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserTokenInfo::clear_push_type() {
  push_type_ = 0u;
  clear_has_push_type();
}
inline ::google::protobuf::uint32 UserTokenInfo::push_type() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.UserTokenInfo.push_type)
  return push_type_;
}
inline void UserTokenInfo::set_push_type(::google::protobuf::uint32 value) {
  set_has_push_type();
  push_type_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.UserTokenInfo.push_type)
}

// -------------------------------------------------------------------

// PushResult

// required string user_token = 1;
inline bool PushResult::has_user_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PushResult::set_has_user_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PushResult::clear_has_user_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PushResult::clear_user_token() {
  if (user_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_->clear();
  }
  clear_has_user_token();
}
inline const ::std::string& PushResult::user_token() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushResult.user_token)
  return *user_token_;
}
inline void PushResult::set_user_token(const ::std::string& value) {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  user_token_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushResult.user_token)
}
inline void PushResult::set_user_token(const char* value) {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  user_token_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.PushResult.user_token)
}
inline void PushResult::set_user_token(const char* value, size_t size) {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  user_token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.PushResult.user_token)
}
inline ::std::string* PushResult::mutable_user_token() {
  set_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.PushResult.user_token)
  return user_token_;
}
inline ::std::string* PushResult::release_user_token() {
  clear_has_user_token();
  if (user_token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_token_;
    user_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PushResult::set_allocated_user_token(::std::string* user_token) {
  if (user_token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_token_;
  }
  if (user_token) {
    set_has_user_token();
    user_token_ = user_token;
  } else {
    clear_has_user_token();
    user_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.PushResult.user_token)
}

// required uint32 result_code = 2;
inline bool PushResult::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PushResult::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PushResult::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PushResult::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 PushResult::result_code() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.PushResult.result_code)
  return result_code_;
}
inline void PushResult::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.PushResult.result_code)
}

// -------------------------------------------------------------------

// ShieldStatus

// required uint32 user_id = 1;
inline bool ShieldStatus::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShieldStatus::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShieldStatus::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShieldStatus::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 ShieldStatus::user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ShieldStatus.user_id)
  return user_id_;
}
inline void ShieldStatus::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ShieldStatus.user_id)
}

// required uint32 group_id = 2;
inline bool ShieldStatus::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShieldStatus::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShieldStatus::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShieldStatus::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 ShieldStatus::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ShieldStatus.group_id)
  return group_id_;
}
inline void ShieldStatus::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ShieldStatus.group_id)
}

// required uint32 shield_status = 3;
inline bool ShieldStatus::has_shield_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShieldStatus::set_has_shield_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShieldStatus::clear_has_shield_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShieldStatus::clear_shield_status() {
  shield_status_ = 0u;
  clear_has_shield_status();
}
inline ::google::protobuf::uint32 ShieldStatus::shield_status() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.ShieldStatus.shield_status)
  return shield_status_;
}
inline void ShieldStatus::set_shield_status(::google::protobuf::uint32 value) {
  set_has_shield_status();
  shield_status_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.ShieldStatus.shield_status)
}

// -------------------------------------------------------------------

// OfflineFileInfo

// required uint32 from_user_id = 1;
inline bool OfflineFileInfo::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OfflineFileInfo::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OfflineFileInfo::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OfflineFileInfo::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 OfflineFileInfo::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.from_user_id)
  return from_user_id_;
}
inline void OfflineFileInfo::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.from_user_id)
}

// required string task_id = 2;
inline bool OfflineFileInfo::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OfflineFileInfo::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OfflineFileInfo::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OfflineFileInfo::clear_task_id() {
  if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_->clear();
  }
  clear_has_task_id();
}
inline const ::std::string& OfflineFileInfo::task_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.task_id)
  return *task_id_;
}
inline void OfflineFileInfo::set_task_id(const ::std::string& value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.task_id)
}
inline void OfflineFileInfo::set_task_id(const char* value) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.OfflineFileInfo.task_id)
}
inline void OfflineFileInfo::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  task_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.OfflineFileInfo.task_id)
}
inline ::std::string* OfflineFileInfo::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    task_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.OfflineFileInfo.task_id)
  return task_id_;
}
inline ::std::string* OfflineFileInfo::release_task_id() {
  clear_has_task_id();
  if (task_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = task_id_;
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OfflineFileInfo::set_allocated_task_id(::std::string* task_id) {
  if (task_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete task_id_;
  }
  if (task_id) {
    set_has_task_id();
    task_id_ = task_id;
  } else {
    clear_has_task_id();
    task_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.OfflineFileInfo.task_id)
}

// required string file_name = 3;
inline bool OfflineFileInfo::has_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OfflineFileInfo::set_has_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OfflineFileInfo::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OfflineFileInfo::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& OfflineFileInfo::file_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.file_name)
  return *file_name_;
}
inline void OfflineFileInfo::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.file_name)
}
inline void OfflineFileInfo::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.OfflineFileInfo.file_name)
}
inline void OfflineFileInfo::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.OfflineFileInfo.file_name)
}
inline ::std::string* OfflineFileInfo::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.OfflineFileInfo.file_name)
  return file_name_;
}
inline ::std::string* OfflineFileInfo::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OfflineFileInfo::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.OfflineFileInfo.file_name)
}

// required uint32 file_size = 4;
inline bool OfflineFileInfo::has_file_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OfflineFileInfo::set_has_file_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OfflineFileInfo::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OfflineFileInfo::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 OfflineFileInfo::file_size() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.file_size)
  return file_size_;
}
inline void OfflineFileInfo::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.file_size)
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 10;
inline int OfflineFileInfo::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline void OfflineFileInfo::clear_ip_addr_list() {
  ip_addr_list_.Clear();
}
inline const ::IM::BaseDefine::IpAddr& OfflineFileInfo::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.ip_addr_list)
  return ip_addr_list_.Get(index);
}
inline ::IM::BaseDefine::IpAddr* OfflineFileInfo::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.OfflineFileInfo.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
inline ::IM::BaseDefine::IpAddr* OfflineFileInfo::add_ip_addr_list() {
  // @@protoc_insertion_point(field_add:IM.BaseDefine.OfflineFileInfo.ip_addr_list)
  return ip_addr_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
OfflineFileInfo::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:IM.BaseDefine.OfflineFileInfo.ip_addr_list)
  return ip_addr_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
OfflineFileInfo::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.BaseDefine.OfflineFileInfo.ip_addr_list)
  return &ip_addr_list_;
}

// optional uint32 send_time = 11;
inline bool OfflineFileInfo::has_send_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OfflineFileInfo::set_has_send_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OfflineFileInfo::clear_has_send_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OfflineFileInfo::clear_send_time() {
  send_time_ = 0u;
  clear_has_send_time();
}
inline ::google::protobuf::uint32 OfflineFileInfo::send_time() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.OfflineFileInfo.send_time)
  return send_time_;
}
inline void OfflineFileInfo::set_send_time(::google::protobuf::uint32 value) {
  set_has_send_time();
  send_time_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.OfflineFileInfo.send_time)
}

// -------------------------------------------------------------------

// DepartInfo

// required uint32 group_id = 1;
inline bool DepartInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DepartInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DepartInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DepartInfo::clear_group_id() {
  group_id_ = 0u;
  clear_has_group_id();
}
inline ::google::protobuf::uint32 DepartInfo::group_id() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DepartInfo.group_id)
  return group_id_;
}
inline void DepartInfo::set_group_id(::google::protobuf::uint32 value) {
  set_has_group_id();
  group_id_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DepartInfo.group_id)
}

// required uint32 group_flag = 2;
inline bool DepartInfo::has_group_flag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DepartInfo::set_has_group_flag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DepartInfo::clear_has_group_flag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DepartInfo::clear_group_flag() {
  group_flag_ = 0u;
  clear_has_group_flag();
}
inline ::google::protobuf::uint32 DepartInfo::group_flag() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DepartInfo.group_flag)
  return group_flag_;
}
inline void DepartInfo::set_group_flag(::google::protobuf::uint32 value) {
  set_has_group_flag();
  group_flag_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DepartInfo.group_flag)
}

// required string group_name = 3;
inline bool DepartInfo::has_group_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DepartInfo::set_has_group_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DepartInfo::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DepartInfo::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& DepartInfo::group_name() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DepartInfo.group_name)
  return *group_name_;
}
inline void DepartInfo::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DepartInfo.group_name)
}
inline void DepartInfo::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.BaseDefine.DepartInfo.group_name)
}
inline void DepartInfo::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.BaseDefine.DepartInfo.group_name)
}
inline ::std::string* DepartInfo::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    group_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.BaseDefine.DepartInfo.group_name)
  return group_name_;
}
inline ::std::string* DepartInfo::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DepartInfo::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.BaseDefine.DepartInfo.group_name)
}

// required uint32 group_sort = 4;
inline bool DepartInfo::has_group_sort() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DepartInfo::set_has_group_sort() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DepartInfo::clear_has_group_sort() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DepartInfo::clear_group_sort() {
  group_sort_ = 0u;
  clear_has_group_sort();
}
inline ::google::protobuf::uint32 DepartInfo::group_sort() const {
  // @@protoc_insertion_point(field_get:IM.BaseDefine.DepartInfo.group_sort)
  return group_sort_;
}
inline void DepartInfo::set_group_sort(::google::protobuf::uint32 value) {
  set_has_group_sort();
  group_sort_ = value;
  // @@protoc_insertion_point(field_set:IM.BaseDefine.DepartInfo.group_sort)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace BaseDefine
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eBaseDefine_2eproto__INCLUDED
